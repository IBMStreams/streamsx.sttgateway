/*
==============================================
# Licensed Materials - Property of IBM
# Copyright IBM Corp. 2018, 2019
==============================================
*/

/*
============================================================
First created on: Jul/01/2018
Last modified on: Nov/06/2019

Please refer to the sttgateway-tech-brief.txt file in the 
top-level directory of this toolkit to read about 
what this toolkit does, how it can be built and 
how it can be used in the Streams applications.

High-level business need for this operator is explained here:
https://github.com/IBMStreams/administration/issues/136
============================================================
*/

/* Additional includes go here */
// https://cloud.ibm.com/docs/services/speech-to-text?topic=speech-to-text-websockets#advantages
// https://docs.websocketpp.org/index.html
// This operator heavily relies on the Websocket++ header only library.
// This C++11 library code does the asynchronous full duplex Websocket communication with
// the Watson STT service via a series of event handlers (a.k.a callback methods).
// Bulk of the logic in this operator class appears in those event handler methods below.
#include <websocketpp/config/asio_client.hpp>
#include <websocketpp/client.hpp>

#include <boost/exception/to_string.hpp>

// A nice read in this URL about using property_tree for JSON parsing:
// http://zenol.fr/blog/boost-property-tree/en.html
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

// Short alias for this namespace
namespace pt = boost::property_tree;

using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

// Verify the input tuple attribute name and then read the operator parameters.
<%
	# Check the input port 0 i.e. the first input port. 
	my $inputPort = $model->getInputPortAt(0);
	my $inputTupleName = $inputPort->getCppTupleName();
	my $audioInputAsBlob = undef;
	my $inputAttrs = $inputPort->getAttributes();
	my $speechAttributeFound = 0;
	my $speechAttributeType = "none";
	
	foreach my $inputAttr (@$inputAttrs) {
		my $inAttrName = $inputAttr->getName();
		my $inAttrType = $inputAttr->getSPLType();
		
		if ($inAttrName eq "speech") {
			$speechAttributeFound = 1;
			
			if ($inAttrType eq "rstring") {
				# This tuple attribute will carry the name of a file containing the audio data.
				$audioInputAsBlob = 0;
				$speechAttributeType = $inputAttr->getCppType();
			}
			
			if ($inAttrType eq "blob") {
				# This tuple attribute will carry a blob containing either full or partial audio data.
				$audioInputAsBlob = 1;
				$speechAttributeType = $inputAttr->getCppType();
			}
		}
	}
	print "// audioInputAsBlob=$audioInputAsBlob speechAttributeType=$speechAttributeType\n";
	
	if ($speechAttributeFound == 0 ) {
		SPL::CodeGen::exitln("WatsonSTT_cpp.cgt: The required input tuple attribute 'speech' is missing in the first input port.");
	}
	
	if (!(defined($audioInputAsBlob))) {
		SPL::CodeGen::exitln("WatsonSTT_cpp.cgt: The required input tuple attribute 'speech' is not of type 'rstring' or 'blob' in the first input port.");
	} else {
		print "//code generated for case \$audioInputAsBlob = $audioInputAsBlob\n";
	}
	
	# Check the input port number 1 i.e. the second input port.
	my $inputPort2 = $model->getInputPortAt(1);
	my $inputTupleName2 = $inputPort2->getCppTupleName();
	my $accessTokenAsString = undef;	
	my $inputAttrs2 = $inputPort2->getAttributes();
	my $accessTokenAttributeFound = 0;
	
	foreach my $inputAttr2 (@$inputAttrs2) {
		my $inAttrName2 = $inputAttr2->getName();
		my $inAttrType2 = $inputAttr2->getSPLType();
		
		if ($inAttrName2 eq "access_token") {
			$accessTokenAttributeFound = 1;
			
			if ($inAttrType2 eq "rstring") {
				# This tuple attribute will carry the IAM access token.
				$accessTokenAsString = 1;
			}
		}
	}
	
	if ($accessTokenAttributeFound == 0 ) {
		SPL::CodeGen::exitln("WatsonSTT_cpp.cgt: The required input tuple attribute 'accessToken' is missing in the second input port.");
	}
	
	if (!(defined($accessTokenAsString))) {
		SPL::CodeGen::exitln("WatsonSTT_cpp.cgt: The required input tuple attribute 'accessToken' is not of type 'rstring' in the second input port.");
	}
	
	# Following are the operator parameters.
	my $uri = $model->getParameterByName("uri");
	$uri = $uri->getValueAt(0)->getCppExpression();

	my $baseLanguageModel = $model->getParameterByName("baseLanguageModel");
	$baseLanguageModel = $baseLanguageModel->getValueAt(0)->getCppExpression();

	# Record the optional parameter values if present. Otherwise, set the default value.
	my $contentType = $model->getParameterByName("contentType");
	$contentType = $contentType ? $contentType->getValueAt(0)->getCppExpression() : "\"audio/wav\"";

	my $sttResultMode = $model->getParameterByName("sttResultMode");
	# Default: 3 for full text result
	$sttResultMode = $sttResultMode ? $sttResultMode->getValueAt(0)->getCppExpression() : 3;

	my $sttRequestLogging = $model->getParameterByName("sttRequestLogging");
	$sttRequestLogging = $sttRequestLogging ? $sttRequestLogging->getValueAt(0)->getCppExpression() : 0;
	
	my $baseModelVersion = $model->getParameterByName("baseModelVersion");
	$baseModelVersion = $baseModelVersion ? $baseModelVersion->getValueAt(0)->getCppExpression() : "\"\"";
	
	my $customizationId = $model->getParameterByName("customizationId");
	$customizationId = $customizationId ? $customizationId->getValueAt(0)->getCppExpression() : "\"\"";
	
	my $customizationWeight = $model->getParameterByName("customizationWeight");
	$customizationWeight = $customizationWeight ? $customizationWeight->getValueAt(0)->getCppExpression() : 9.9;
	
	my $acousticCustomizationId = $model->getParameterByName("acousticCustomizationId");
	$acousticCustomizationId = $acousticCustomizationId ? $acousticCustomizationId->getValueAt(0)->getCppExpression() : "\"\"";

	my $filterProfanity = $model->getParameterByName("filterProfanity");
	$filterProfanity = $filterProfanity ? $filterProfanity->getValueAt(0)->getCppExpression() : 0;

	my $sttJsonResponseDebugging = $model->getParameterByName("sttJsonResponseDebugging");
	$sttJsonResponseDebugging = $sttJsonResponseDebugging ? $sttJsonResponseDebugging->getValueAt(0)->getCppExpression() : 0;

	my $maxUtteranceAlternatives = $model->getParameterByName("maxUtteranceAlternatives");
	# Default: 1 for a single result in the JSON alternatives array.
	$maxUtteranceAlternatives = $maxUtteranceAlternatives ? $maxUtteranceAlternatives->getValueAt(0)->getCppExpression() : 1;

	my $wordAlternativesThreshold = $model->getParameterByName("wordAlternativesThreshold");
	# Default: 0.0 to distable the wordAlternatives feature (a.k.a Confusion Networks).
	$wordAlternativesThreshold = $wordAlternativesThreshold ? $wordAlternativesThreshold->getValueAt(0)->getCppExpression() : 0.0;

	my $wordConfidenceNeeded = $model->getParameterByName("wordConfidenceNeeded");
	$wordConfidenceNeeded = $wordConfidenceNeeded ? $wordConfidenceNeeded->getValueAt(0)->getCppExpression() : 0;
	
	my $wordTimestampNeeded = $model->getParameterByName("wordTimestampNeeded");
	$wordTimestampNeeded = $wordTimestampNeeded ? $wordTimestampNeeded->getValueAt(0)->getCppExpression() : 0;

	my $identifySpeakers = $model->getParameterByName("identifySpeakers");
	$identifySpeakers = $identifySpeakers ? $identifySpeakers->getValueAt(0)->getCppExpression() : 0;

	my $smartFormattingNeeded = $model->getParameterByName("smartFormattingNeeded");
	$smartFormattingNeeded = $smartFormattingNeeded ? $smartFormattingNeeded->getValueAt(0)->getCppExpression() : 0;

	my $keywordsSpottingThreshold = $model->getParameterByName("keywordsSpottingThreshold");
	# Default: 0.0 to distable the keywords spotting feature.
	$keywordsSpottingThreshold = $keywordsSpottingThreshold ? $keywordsSpottingThreshold->getValueAt(0)->getCppExpression() : 0.0;
	
	my $keywordsToBeSpotted = $model->getParameterByName("keywordsToBeSpotted");
	$keywordsToBeSpotted = $keywordsToBeSpotted ? $keywordsToBeSpotted->getValueAt(0)->getCppExpression() : "SPL::list<SPL::rstring>{}";

	my $websocketLoggingNeeded = $model->getParameterByName("websocketLoggingNeeded");
	$websocketLoggingNeeded = $websocketLoggingNeeded ? $websocketLoggingNeeded->getValueAt(0)->getCppExpression() : 0;

	my $cpuYieldTimeInAudioSenderThread = $model->getParameterByName("cpuYieldTimeInAudioSenderThread");
	# Default: 0.001 second i.e. 1 millisecond of CPU yield time inside a tight loop.
	$cpuYieldTimeInAudioSenderThread = $cpuYieldTimeInAudioSenderThread ? $cpuYieldTimeInAudioSenderThread->getValueAt(0)->getCppExpression() : 0.001;

	my $waitTimeBeforeSTTServiceConnectionRetry = $model->getParameterByName("waitTimeBeforeSTTServiceConnectionRetry");
	# Default: 3.0 seconds.
	$waitTimeBeforeSTTServiceConnectionRetry = $waitTimeBeforeSTTServiceConnectionRetry ? $waitTimeBeforeSTTServiceConnectionRetry->getValueAt(0)->getCppExpression() : 3.0;

	my $connectionAttemptsThreshold = $model->getParameterByName("connectionAttemptsThreshold");
	# Default: 10 attempts
	$connectionAttemptsThreshold = $connectionAttemptsThreshold ? $connectionAttemptsThreshold->getValueAt(0)->getCppExpression() : 10;
	
	my $sttLiveMetricsUpdateNeeded = $model->getParameterByName("sttLiveMetricsUpdateNeeded");
	$sttLiveMetricsUpdateNeeded = $sttLiveMetricsUpdateNeeded ? $sttLiveMetricsUpdateNeeded->getValueAt(0)->getCppExpression() : 1;
%>

<%SPL::CodeGen::implementationPrologue($model);%>

// Constructor
MY_OPERATOR::MY_OPERATOR()
:
		MY_BASE_OPERATOR{},
		impl(
				*this,
				<%=$websocketLoggingNeeded%>,
				<%=$cpuYieldTimeInAudioSenderThread%>,
				<%=$waitTimeBeforeSTTServiceConnectionRetry%>,
				<%=$connectionAttemptsThreshold%>,
				<%=$sttLiveMetricsUpdateNeeded%>,
				<%=$uri%>,
				<%=$baseLanguageModel%>,
				<%=$contentType%>,
				<%=$sttResultMode%>,
				<%=$sttRequestLogging%>,
				<%=$baseModelVersion%>,
				<%=$customizationId%>,
				<%=$customizationWeight%>,
				<%=$acousticCustomizationId%>,
				<%=$filterProfanity%>,
				<%=$sttJsonResponseDebugging%>,
				<%=$maxUtteranceAlternatives%>,
				<%=$wordAlternativesThreshold%>,
				<%=$wordConfidenceNeeded%>,
				<%=$wordTimestampNeeded%>,
				<%=$identifySpeakers%>,
				<%=$smartFormattingNeeded%>,
				<%=$keywordsSpottingThreshold%>,
				<%=$keywordsToBeSpotted%>
				)
{
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
}

// To set the static variable present inside this method, 
// call this method with a non-null object i.e. this object as input.
// To get the value of the static variable present inside this method,
// call this method with a null object as input.
//
// NOTE: I originally built this method for a different reason to have
// static member methods as callback functions for the Websocket event handlers.
// From those static methods, this method was called to get the object pointer of
// this operator class to access the member variables like this:
// MY_OPERATOR::myOp(NULL)->some_member_variable
// Later (on Aug/28/2018) I removed the need for the static methods. 
// Hence, this method is no longer in use.
/*
MY_OPERATOR* MY_OPERATOR::myOp(MY_OPERATOR* obj) {
	static MY_OPERATOR* thisObj = NULL;

	if (obj == NULL) {
		return(thisObj);
	}
		
	thisObj = obj;
	return(thisObj);
}
*/

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
	impl.allPortsReady();
	return;
}

void MY_OPERATOR::process(uint32_t idx) {
	impl.process(idx);
	return;
}

// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
	impl.prepareToShutdown();
	return;
}


// This operator has two input ports.
// Port 0: Audio data (a file name or a blob) arrives on this port. (mutating)
// Port 1: It is a control port where the IAM access token is
//         sent into this operator for connecting to the
//         STT service in a secure manner. (non mutating)

//Non mutating port 1
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {
	// Let is first process if the IAM access token is sent via port 1 i.e. second input port.
	if (port != 1)
		throw std::invalid_argument("Port number is not 1");

	IPort1Type const & inputTuple = static_cast<IPort1Type const &>(tuple);
	impl.process_1<IPort1Type, &IPort1Type::get_access_token>(inputTuple);
	
	return;
}

// With the WebSocket interface, audio data is always streamed to the 
// STT service over the connection. You can pass the blob data through the 
// Websocket all at once, or you can pass data for the live-use case 
// as it becomes available.
//
// Since the Websocket interface keeps its request/response communication to 
// the STT service completely asynchronus on the full duplex TCP connection,
// our tuple processing here is going to be different from the way it is 
// usually done inside the Streams operators. 
// There will be multiple threads: One for receiving tuples on this 
// operator's input port, one for sending the audio data to the 
// STT service and another for receiving transcription responses from the 
// STT service as well as to send the output tuples on this operator's 
// output port. It is somewhat different from the usual stuff and 
// very involved in terms of the logic. So, read the code completely to 
// understand what is going on inside all these threads.

//Mutating port 0
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
	if (port != 0)
		throw std::invalid_argument("Port number is not 0");

	IPort0Type & <%=$inputTupleName%> = static_cast<IPort0Type &>(tuple);
	impl.process_0<IPort0Type, <%=$speechAttributeType%>, &IPort0Type::get_speech>(<%=$inputTupleName%>, <%=$speechAttributeType%>());
	
	return;
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port) {
	// Forward the punctuation markers on our first output port.
	// Final markers are handled from streams runtime -> see Operator model finalPunctuationPortScope
	if (port == 0) {
		if(punct==Punctuation::WindowMarker) {
			submit(punct, 0);
		}
	}
	return;
}


//Create a output tuple and auto assign values from an input tuple
MY_OPERATOR::OPort0Type* MY_OPERATOR::createOutTupleAndAutoAssign(MY_OPERATOR::IPort0Type const& <%=$inputTupleName%>) {
	OPort0Type *oTuple = new OPort0Type;
	
	if (oTuple == NULL) {
		// Object instantiation (memory allocation) error.
		throw std::bad_alloc();
			//Don't try to allocate further strings
			//"WatsonSTT_cpp.cgt: Unable to create a new oTuple object in the process method.");
	}
	
<%	my $oport = $model->getOutputPortAt(0); 
	foreach my $attribute (@{$oport->getAttributes()}) { 
		my $name = $attribute->getName(); 
		# print "// $name\n";
		my $operation = $attribute->getAssignmentOutputFunctionName();
		# print "// $operation\n";
		if ($operation eq "AsIs") { 
			my $init = $attribute->getAssignmentOutputFunctionParameterValueAt(0)->getCppExpression();
%>
			oTuple->set_<%=$name%>(<%=$init%>);
<%
		}
	}
%>
	return oTuple;
}

// Assign the error message to output tuple
void MY_OPERATOR::setErrorAttribute(OPort0Type * tuple, std::string const & errorMessage) {
<% 
	my $oport = $model->getOutputPortAt(0); 
	foreach my $attribute (@{$oport->getAttributes()}) { 
		my $name = $attribute->getName(); 
		my $paramValues = $attribute->getAssignmentOutputFunctionParameterValues();
		my $operation = $attribute->getAssignmentOutputFunctionName();

		if ($operation eq "getSTTErrorMessage") {
%>
			tuple->set_<%=$name%>(SPL::rstring(errorMessage)); 
<%		}
	}
%>
	return;
}

// Assign result attributes except speaker results and transcription complete to output tuple
void MY_OPERATOR::setResultAttributes(
		OPort0Type * tuple,
		int32_t utteranceNumber_,
		std::string const & utteranceText_,
		bool final_,
		float confidence_,
		std::string const & fullTranscriptionText_,
		SPL::list<SPL::rstring> const & utteranceAlternatives_,
		SPL::list<SPL::list<SPL::rstring>> const & wordAlternatives_,
		SPL::list<SPL::list<SPL::float64>> const & wordAlternativesConfidences_,
		SPL::list<SPL::float64> const & wordAlternativesStartTimes_,
		SPL::list<SPL::float64> const & wordAlternativesEndTimes_,
		SPL::list<SPL::rstring> const & utteranceWords_,
		SPL::list<SPL::float64> const & utteranceWordsConfidences_,
		SPL::list<SPL::float64> const & utteranceWordsEndTimes_,
		SPL::float64 utteranceStartTime_,
		SPL::float64 utteranceEndTime_,
		SPL::map<SPL::rstring, SPL::list<SPL::map<SPL::rstring, SPL::float64>>> const & keywordsSpottingResults_
) {
<% 
	my $oport = $model->getOutputPortAt(0); 
	foreach my $attribute (@{$oport->getAttributes()}) {
		my $name = $attribute->getName(); 
		my $paramValues = $attribute->getAssignmentOutputFunctionParameterValues();
		my $operation = $attribute->getAssignmentOutputFunctionName(); 

		if ($operation eq "getUtteranceNumber") {
%>
			// Utterance number starts from 0. Hence, add 1 to it.
			tuple->set_<%=$name%>(utteranceNumber_ + 1);
<%		} elsif ($operation eq "getUtteranceText") { %>
			tuple->set_<%=$name%>(utteranceText_);
<%		} elsif ($operation eq "isFinalizedUtterance") { %>
			tuple->set_<%=$name%>(final_);
<%		} elsif ($operation eq "getConfidence") { %>
			tuple->set_<%=$name%>(confidence_);
<%		} elsif ($operation eq "getFullTranscriptionText") { %>
			tuple->set_<%=$name%>(fullTranscriptionText_);
<%		} elsif ($operation eq "isTranscriptionCompleted") { %>
			tuple->set_<%=$name%>(false);
<%		} elsif ($operation eq "getUtteranceAlternatives") { %>
			tuple->set_<%=$name%>(utteranceAlternatives_);
<%		} elsif ($operation eq "getWordAlternatives") { %>
			tuple->set_<%=$name%>(wordAlternatives_);
<%		} elsif ($operation eq "getWordAlternativesConfidences") { %>
			tuple->set_<%=$name%>(wordAlternativesConfidences_);
<%		} elsif ($operation eq "getWordAlternativesStartTimes") { %>
			tuple->set_<%=$name%>(wordAlternativesStartTimes_);
<%		} elsif ($operation eq "getWordAlternativesEndTimes") { %>
			tuple->set_<%=$name%>(wordAlternativesEndTimes_);
<%		} elsif ($operation eq "getUtteranceWords") { %>
			tuple->set_<%=$name%>(utteranceWords_);
<%		} elsif ($operation eq "getUtteranceWordsConfidences") { %>
			tuple->set_<%=$name%>(utteranceWordsConfidences_);
<%		} elsif ($operation eq "getUtteranceWordsStartTimes") { %>
			//tuple->set_<%=$name%>(impl.<%=$operation%>());
			tuple->set_<%=$name%>(impl.utteranceWordsStartTimes);
<%		} elsif ($operation eq "getUtteranceWordsEndTimes") { %>
			tuple->set_<%=$name%>(utteranceWordsEndTimes_);
<%		} elsif ($operation eq "getUtteranceStartTime") { %>
			tuple->set_<%=$name%>(utteranceStartTime_);
<%		} elsif ($operation eq "getUtteranceEndTime") { %>
			tuple->set_<%=$name%>(utteranceEndTime_);
<%		} elsif ($operation eq "getUtteranceWordsSpeakers") { %>
			//tuple->set_<%=$name%>(impl.<%=$operation%>());
			tuple->set_<%=$name%>(impl.utteranceWordsSpeakers);
<%		} elsif ($operation eq "getUtteranceWordsSpeakersConfidences") { %>
			//tuple->set_<%=$name%>(impl.<%=$operation%>());
			tuple->set_<%=$name%>(impl.utteranceWordsSpeakersConfidences);
<%		} elsif ($operation eq "getKeywordsSpottingResults") { %>
			tuple->set_<%=$name%>(keywordsSpottingResults_);
<%
		}
	}
%>
	return;
}

// Assign speaker result to output tuple
void MY_OPERATOR::setSpeakerResultAttributes(OPort0Type * tuple) {
<% 
	my $oport = $model->getOutputPortAt(0);
	foreach my $attribute (@{$oport->getAttributes()}) {
		my $name = $attribute->getName();
		my $paramValues = $attribute->getAssignmentOutputFunctionParameterValues();
		my $operation = $attribute->getAssignmentOutputFunctionName();

		if ($operation eq "getUtteranceWordsSpeakers") {
%>
			//tuple->set_<%=$name%>(impl.<%=$operation%>());
			tuple->set_<%=$name%>(impl.utteranceWordsSpeakers);
<%		} elsif ($operation eq "getUtteranceWordsSpeakersConfidences") { %>
			//tuple->set_<%=$name%>(impl.<%=$operation%>());
			tuple->set_<%=$name%>(impl.utteranceWordsSpeakersConfidences);
<%
		}
	}
%>
	return;
}

// Assign transcription complete attribute to output tuple
void MY_OPERATOR::setTranscriptionCompleteAttribute(OPort0Type * tuple) {
<% 
	my $oport = $model->getOutputPortAt(0);
	foreach my $attribute (@{$oport->getAttributes()}) {
	my $name = $attribute->getName();
		my $paramValues = $attribute->getAssignmentOutputFunctionParameterValues();
		my $operation = $attribute->getAssignmentOutputFunctionName();

		if ($operation eq "isTranscriptionCompleted") {
%>
			tuple->set_<%=$name%>(true);
<%		}
	}
%>
	return;
}

<%SPL::CodeGen::implementationEpilogue($model);%>
