/*
==============================================
# Licensed Materials - Property of IBM
# Copyright IBM Corp. 2019
==============================================
*/

/*
==============================================
First created on: Jun/11/2019
Last modified on: Dec/16/2019

This non-main composite provides a way to generate a
new IAM access token for the IBM STT service on
public cloud. IBM Streams applications using
the streamsx.sttgateway can use/invoke this non-main composite to
generate and periodically refresh the IAM access token which will be
required by the WatsonSTT operator. Without having an
unexpired IAM access token, STT service on public cloud will not
allow the speech to text transcription to happen.

If the sttAPIKey parameter below is set to an empty string,
this composite will skip generating an IamAccessToken.
==============================================
*/

namespace com.ibm.streamsx.sttgateway.watson;

// This non-main composite uses JSON native functions.
// So, the following toolkit (v1.4.6 or higher) is a dependency.
use com.ibm.streamsx.json::*;
use com.ibm.streamsx.inet.http::HTTPRequest;

// This type represents the data format for the 
// result returned by the "Generate IAM access token" and the
// "Refresh IAM access token" CURL commands.
type IamAccessToken_t = rstring access_token, rstring refresh_token, 
	rstring scope, int64 expiration, rstring token_type, int64 expires_in;

public composite IAMAccessTokenGenerator(output IamAccessToken) {
	param
		// IMPORTANT: The WatsonSTT operator uses Websocket to communicate with the 
		// Watson STT service. For the STT service on public cloud, one must use 
		// the unexpired IAM access token (generated by using your 
		// public cloud STT service instance's API key). So, user must provide here his/her API key.
		// We have some logic below that will use the user provided API key to
		// generate the IAM access token and send that to the WatsonSTT operator.
		// There is additional logic available below to keep refreshing that
		// IAM access token periodically in order for it to stay unexpired.
		// https://cloud.ibm.com/docs/services/speech-to-text?topic=speech-to-text-websockets#WSopen
		// 
		// This composite accepts these four operator parameters.
		expression<rstring> $sttApiKey;
		// Specify either the public cloud IAM Token fetch/refresh URL.
		expression<rstring> $sttIAMTokenURL;
		// Specify the access token refresh interval in minutes.
		expression<float64> $sttAccessTokenRefreshInterval;
		// Initial delay before generating the IAM access token.
		expression<float64> $initDelay: 0.0;

	graph
		// ========== START OF GENERATING AND REFRESHING AN IAM ACCESS TOKEN ==========
		// In order to keep doing the STT transcription continuously, 
		// the IBM STT service on public cloud will require an
		// unexpired IAM access token. In this non-main composite, we will 
		// generate a new IAM access token by using the user-provided IBM public cloud STT service
		// instance's app key and the IAM access token generation URL. In addition, we will
		// also keep refreshing the access token for it to stay valid and not get expired.
		// By default, an IAM access token will expire after one hour. So, we will do a 
		// special logic here to keep the IAM access token unexpired.
		(stream<uint64 counter, rstring method, rstring grant_type, rstring apikey> IamTokenSignal as O) = Beacon() {
			param
				initDelay: $initDelay;
				period: $sttAccessTokenRefreshInterval * 60.00;
			output O:
				counter = IterationCount(),
				method = IterationCount() == 0ul ? "POST" : "NONE",
				grant_type = IterationCount() == 0ul ? "urn:ibm:params:oauth:grant-type:apikey" : "refresh_token",
				apikey = $sttApiKey;
		}
	
		// The initial request is made from this operator
		// It must deliver the first access token and the refresh token for
		// subsequent refresh requests
		// Attributes of this request are grant_type and apikey
		stream<uint64 counter, rstring method, rstring grant_type, rstring response, rstring status, int32 statusCode, 
			rstring outContentType, list<rstring> outHeader, 
			rstring diags> IamAccessTokenJson1
		= HTTPRequest(IamTokenSignal){
			param
				fixedUrl: $sttIAMTokenURL;
				method: method;
				fixedContentType: "application/x-www-form-urlencoded";
				extraHeaders: "Authorization: Basic Yng6Yng=", "Accept: application/json";
				requestAttributes: "grant_type", "apikey";
				outputStatus: "status";
				outputStatusCode: "statusCode";
				outputBody: "response";
				outputContentType: "outContentType";
				outputHeader: "outHeader";
				errorDiagnostics: "diags";
		}
		
		// This operator extracts the first access_token and the refresh token, if the request succeeds
		stream<uint64 counter, rstring method, rstring grant_type, rstring refresh_token, IamAccessToken_t firstResponse> GeneratedIamAccessToken1 as O
		= Custom(IamAccessTokenJson1 as I) {
			logic
				state: mutable rstring my_refresh_token = "";
				onTuple I: {
					if (counter == 0ul) {
						if ((statusCode >= 200) && (statusCode < 300)) {
							appTrc(Trace.trace, "Received response1=" + (rstring)I, "GeneratedIamAccessToken1");
							mutable O otuple = {};
							assignFrom(I,O);
							extractFromJSON(response, otuple.firstResponse);
							if (otuple.firstResponse.access_token != "") {
								// save resfresh token for following refresh operations
								my_refresh_token = otuple.firstResponse.refresh_token;
								// Change method to NONE for second HTTPRequest operator
								otuple.method = "NONE";
								submit(otuple, O);
							} else {
								appTrc(Trace.error, "An empty IAM access token was obtained during token generation 1. " +
									"response1=" + (rstring)I + ". Aborting now.", "GeneratedIamAccessToken1");
								abort();
							}
						} else {
							appTrc(Trace.error, "Non successful response received during token generation 1. " +
								"Tuple=" + (rstring)I + ". Aborting now.", "GeneratedIamAccessToken1");
							abort();
						}
					} else {
						mutable O otuple = {};
						assignFrom(otuple, I);
						// Change method to POST for second HTTPRequest operator
						otuple.method = "POST";
						otuple.grant_type = "refresh_token";
						// restore refresh_token
						otuple.refresh_token = my_refresh_token;
						appTrc(Trace.trace, "Send=" + (rstring)otuple, "GeneratedIamAccessToken1");
						submit(otuple, O);
					}
				}
		}
		
		// Operator for subsequent refresh requests
		// Attributes of this request are grant_type and apikey
		stream<uint64 counter, rstring response, rstring status, int32 statusCode, IamAccessToken_t firstResponse,
			rstring outContentType, list<rstring> outHeader, rstring diags> IamAccessTokenJson2
		= HTTPRequest(GeneratedIamAccessToken1){
			param
				fixedUrl: $sttIAMTokenURL;
				method: method;
				fixedContentType: "application/x-www-form-urlencoded";
				extraHeaders: "Authorization: Basic Yng6Yng=", "Accept: application/json";
				requestAttributes: "grant_type", "refresh_token";
				outputStatus: "status";
				outputStatusCode: "statusCode";
				outputBody: "response";
				outputContentType: "outContentType";
				outputHeader: "outHeader";
				errorDiagnostics: "diags";
		}

		// This operator extracts the first access_token and the refresh token, if the request succeeds
		stream<IamAccessToken_t> IamAccessToken as O
		= Custom(IamAccessTokenJson2 as I) {
			logic
				onTuple I: {
					if (counter != 0ul) {
						if ((statusCode >= 200) && (statusCode < 300)) {
							appTrc(Trace.trace, "Received response2=" + (rstring)I, "GeneratedIamAccessToken2");
							mutable O otuple = {};
							extractFromJSON(response, otuple);
							if (otuple.access_token != "") {
								appTrc(Trace.trace, "Send IamAccessToken=" + (rstring)otuple, "GeneratedIamAccessToken2");
								submit(otuple, O);
							} else {
								appTrc(Trace.error, "An empty IAM access token was obtained during token generation 2. " +
									"response1=" + (rstring)I + ". Aborting now.", "GeneratedIamAccessToken2");
								abort();
							}
						} else {
							appTrc(Trace.error, "Non successful response received during token generation 2. " +
								"Tuple=" + (rstring)I + ". Aborting now.", "GeneratedIamAccessToken2");
							abort();
						}
					} else {
						appTrc(Trace.trace, "Send IamAccessToken=" + (rstring)I.firstResponse, "GeneratedIamAccessToken2");
						submit(I.firstResponse, O);
					}
				}
		}
} // End of the non-main composite
