/*
==============================================
# Licensed Materials - Property of IBM
# Copyright IBM Corp. 2019, 2021
==============================================
*/

/*
============================================================
First created on: Sep/20/2019
Last modified on: Feb/09/2021

Please refer to the sttgateway-tech-brief.txt file in the 
top-level directory of this toolkit to read about 
what this toolkit does, how it can be built and 
how it can be used in the Streams applications.

This particular operator (IBMVoiceGatewaySource) is used to
integrate IBM Streams with the IBM Voice Gateway product for
receiving the live voice calls typically in a call center
environment.

The IBMVoiceGatewaySource operator is designed to ingest speech data from the 
IBM Voice Gateway product version 1.0.3.0 or above. This speech data is 
ingested in binary format from the IBM Voice Gateway into this operator 
via the Websocket interface. Such speech data arrives here in multiple 
fragments directly from a live voice call. This operator is capable of 
receiving speech data from multiple calls that can all happen at the 
very same time between different pairs of speakers. For every voice call 
it handles in real-time, the IBM Voice Gateway product will open two 
Websocket connections into this operator and start sending the live 
speech data on both of those connections. One of those connections will 
carry the speech data of the agent and the other connection will 
carry the speech data of the customer. This operator will keep sending 
the audio chunks received on those two Websocket connections via its 
output stream for consumption by the downstream operators. At the end of 
the any given call, IBM Voice Gateway will close the two 
WebSocket connections it opened into this operator.
============================================================
*/
#include <SPL/Runtime/ProcessingElement/ProcessingElement.h>

/* Additional includes go here */
// https://cloud.ibm.com/docs/services/speech-to-text?topic=speech-to-text-websockets#advantages
// https://docs.websocketpp.org/index.html
// This operator heavily relies on the Websocket++ header only library.
// This C++11 library code does the asynchronous full duplex Websocket communication with
// the IBM Voice Gatwway via a series of event handlers (a.k.a callback methods).
// Bulk of the logic in this operator class appears in those event handler methods below.
#include <websocketpp/config/asio.hpp>
#include <websocketpp/server.hpp>

#include <boost/algorithm/string/predicate.hpp>
#include <boost/exception/to_string.hpp>
#include <set>

// A nice read in this URL about using property_tree for JSON parsing:
// http://zenol.fr/blog/boost-property-tree/en.html
// Use define to avoid warning:
// include/boost/bind.hpp:41:265: note: #pragma message: The practice of declaring the Bind placeholders (_1, _2, ...) in the global namespace is deprecated. Please use <boost/bind/bind.hpp> + using namespace boost::placeholders, or define BOOST_BIND_GLOBAL_PLACEHOLDERS to retain the current behavior.
#define BOOST_BIND_GLOBAL_PLACEHOLDERS
// The problem will be fixed in next boost version see:
// https://github.com/boostorg/property_tree/issues/51
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

// Short alias for this namespace
namespace pt = boost::property_tree;

using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

// Verify the input tuple attribute name and then read the operator parameters.
<%
	require SttGatewayResource;

	my $ccContext = $model->getContext()->getOptionalContext("ConsistentRegion");
	if (defined $ccContext) {
	SPL::CodeGen::exitln(SttGatewayResource::STTGW_CONSISTENT_CHECK("IBMVoiceGatewaySource"),
			$model->getContext()->getSourceLocation());
}

	# Check the output port 0 i.e. the first output port. 
	my $outputPort1 = $model->getOutputPortAt(0);
	my $outputTupleName1 = $outputPort1->getCppTupleName();
	my $audioOutputAsBlob = undef;	
	my $outputAttrs1 = $outputPort1->getAttributes();
	my $speechAttributeFound = 0;
	my $vgwSessionIdAsString = undef;
	my $vgwSessionIdAttributeFound = 0;
	my $isCustomerSpeechDataAsBoolean = undef;	
	my $isCustomerSpeechDataAttributeFound = 0;
	my $vgwVoiceChannelNumberAsInt32 = undef;	
	my $vgwVoiceChannelNumberAttributeFound = 0;
	my $endOfCallSignalAsBoolean = undef;	
	my $endOfCallSignalAttributeFound = 0;

	
	foreach my $outputAttr (@$outputAttrs1) {
		my $outAttrName = $outputAttr->getName();
		my $outAttrType = $outputAttr->getSPLType();
		
		if ($outAttrName eq "speech") {
			$speechAttributeFound = 1;
			
			if ($outAttrType eq "blob") {
				# This tuple attribute will carry a blob containing the speech data.
				$audioOutputAsBlob = 1;
			}
		}
		
		if ($outAttrName eq "vgwSessionId") {
			$vgwSessionIdAttributeFound = 1;
			
			if ($outAttrType eq "rstring") {
				# This tuple attribute will carry the Voice Gateway Session Id.
				$vgwSessionIdAsString = 1;
			}
		}
		
		if ($outAttrName eq "isCustomerSpeechData") {
			$isCustomerSpeechDataAttributeFound = 1;
			
			if ($outAttrType eq "boolean") {
				# This tuple attribute will indicate whether the
				# given channel of a given voice call carried the 
				# speech data of a customer or an agent.
				$isCustomerSpeechDataAsBoolean = 1;
			}
		}

		if ($outAttrName eq "vgwVoiceChannelNumber") {
			$vgwVoiceChannelNumberAttributeFound = 1;
			
			if ($outAttrType eq "int32") {
				# This tuple attribute will indicate the
				# channel number of given voice call.
				$vgwVoiceChannelNumberAsInt32 = 1;
			}
		}
		
		if ($outAttrName eq "endOfCallSignal") {
			$endOfCallSignalAttributeFound = 1;
			
			if ($outAttrType eq "boolean") {
				# This tuple attribute will indicate whether the
				# given channel of a given voice call has ended 
				# sending speech data by closing its WebSocket connection.
				$endOfCallSignalAsBoolean = 1;
			}
		}
	}
	
	if ($speechAttributeFound == 0 ) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_CHECK1("IBMVoiceGatewaySource", "speech"),
				$model->getContext()->getSourceLocation());
	}
	
	if (!(defined($audioOutputAsBlob))) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_TYPE_CHECK1("IBMVoiceGatewaySource", "speech", "blob"),
				$model->getContext()->getSourceLocation());
	}

	if ($vgwSessionIdAttributeFound == 0 ) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_CHECK2("IBMVoiceGatewaySource", "vgwSessionId"),
				$model->getContext()->getSourceLocation());
	}
	
	if (!(defined($vgwSessionIdAsString))) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_TYPE_CHECK2("IBMVoiceGatewaySource", "vgwSessionId", "rstring"),
				$model->getContext()->getSourceLocation());
	}

	if ($isCustomerSpeechDataAttributeFound == 0 ) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_CHECK2("IBMVoiceGatewaySource", "isCustomerSpeechData"),
				$model->getContext()->getSourceLocation());
	}
	
	if (!(defined($isCustomerSpeechDataAsBoolean))) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_TYPE_CHECK2("IBMVoiceGatewaySource", "isCustomerSpeechData", "boolean"),
				$model->getContext()->getSourceLocation());
	}

	if ($vgwVoiceChannelNumberAttributeFound == 0 ) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_CHECK2("IBMVoiceGatewaySource", "vgwVoiceChannelNumber"),
				$model->getContext()->getSourceLocation());
	}
	
	if (!(defined($vgwVoiceChannelNumberAsInt32))) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_TYPE_CHECK2("IBMVoiceGatewaySource", "vgwVoiceChannelNumber", "int32"),
				$model->getContext()->getSourceLocation());
	}

	if ($endOfCallSignalAttributeFound == 0 ) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_CHECK2("IBMVoiceGatewaySource", "endOfCallSignal"),
				$model->getContext()->getSourceLocation());
	}
	
	if (!(defined($endOfCallSignalAsBoolean))) {
		SPL::CodeGen::exitln(SttGatewayResource::STTGW_OUT_ATTRIBUTE_TYPE_CHECK2("IBMVoiceGatewaySource", "endOfCallSignal", "boolean"),
				$model->getContext()->getSourceLocation());
	}
	
	# Following are the operator parameters.
    my $tlsPort = $model->getParameterByName("tlsPort");
	# Default: 443
    $tlsPort = $tlsPort ? $tlsPort->getValueAt(0)->getCppExpression() : 443;

    my $certificateFileName = $model->getParameterByName("certificateFileName");
	# Default: Default is to read ws-server.pem from the etc sub-directory of the application.
    $certificateFileName = $certificateFileName ? $certificateFileName->getValueAt(0)->getCppExpression() : "";

    my $certificatePassword = $model->getParameterByName("certificatePassword");
    # Default: Empty string.
    $certificatePassword = $certificatePassword ? $certificatePassword->getValueAt(0)->getCppExpression() : "";
    
    my $nonTlsEndpointNeeded = $model->getParameterByName("nonTlsEndpointNeeded");
	# Default: 0
    $nonTlsEndpointNeeded = $nonTlsEndpointNeeded ? $nonTlsEndpointNeeded->getValueAt(0)->getCppExpression() : 0;    

    my $nonTlsPort = $model->getParameterByName("nonTlsPort");
	# Default: 80
    $nonTlsPort = $nonTlsPort ? $nonTlsPort->getValueAt(0)->getCppExpression() : 80;

    my $initDelay = $model->getParameterByName("initDelay");
	# Default: 0.0
    $initDelay = $initDelay ? $initDelay->getValueAt(0)->getCppExpression() : 0.0;
        
    my $vgwLiveMetricsUpdateNeeded = $model->getParameterByName("vgwLiveMetricsUpdateNeeded");
	# Default: 1
    $vgwLiveMetricsUpdateNeeded = $vgwLiveMetricsUpdateNeeded ? $vgwLiveMetricsUpdateNeeded->getValueAt(0)->getCppExpression() : 1;    

    my $websocketLoggingNeeded = $model->getParameterByName("websocketLoggingNeeded");
	# Default: 0
    $websocketLoggingNeeded = $websocketLoggingNeeded ? $websocketLoggingNeeded->getValueAt(0)->getCppExpression() : 0;    

    my $vgwSessionLoggingNeeded = $model->getParameterByName("vgwSessionLoggingNeeded");
	# Default: 0
    $vgwSessionLoggingNeeded = $vgwSessionLoggingNeeded ? $vgwSessionLoggingNeeded->getValueAt(0)->getCppExpression() : 0;
 
    my $vgwStaleSessionPurgeInterval = $model->getParameterByName("vgwStaleSessionPurgeInterval");
	# Default: 3*60*60 seconds
    $vgwStaleSessionPurgeInterval = $vgwStaleSessionPurgeInterval ? $vgwStaleSessionPurgeInterval->getValueAt(0)->getCppExpression() : 3*60*60;

    my $ipv6Available = $model->getParameterByName("ipv6Available");
	# Default: 1
    $ipv6Available = $ipv6Available ? $ipv6Available->getValueAt(0)->getCppExpression() : 1;    
    %>
        
<%SPL::CodeGen::implementationPrologue($model);%>

// Constructor
MY_OPERATOR::MY_OPERATOR()
{
	// Custom metrics for this operator are already defined in the operator model XML file. 
	// Hence, there is no need to explicitly create them here.
	// Simply get the custom metrics already defined for this operator. 
	// We will update the custom metrics during transcription only when the 
	// sttLiveMetricsUpdateNeeded optional operator parameter is set to true.
	OperatorMetrics  & opm = getContext().getMetrics();
	nVoiceCallsProcessedMetric = & opm.getCustomMetricByName("nVoiceCallsProcessed");
	nSpeechDataBytesReceivedMetric = & opm.getCustomMetricByName("nSpeechDataBytesReceived");
	nOutputTuplesSentMetric = & opm.getCustomMetricByName("nOutputTuplesSent");
	nTlsPortMetric = & opm.getCustomMetricByName("nTlsPort");
	nNonTlsPortNeededMetric = &opm.getCustomMetricByName("nNonTlsPortNeeded");
	nNonTlsPortMetric = &opm.getCustomMetricByName("nNonTlsPort");

	// Initialize the member variables as needed from the operator parameter values read above.	
	tlsPort = <%=$tlsPort%>;
	nonTlsEndpointNeeded = <%=$nonTlsEndpointNeeded%>;
	nonTlsPort = <%=$nonTlsPort%>;
	initDelay = <%=$initDelay%>;
	vgwLiveMetricsUpdateNeeded = <%=$vgwLiveMetricsUpdateNeeded%>;
	websocketLoggingNeeded = <%=$websocketLoggingNeeded%>;
	vgwSessionLoggingNeeded = <%=$vgwSessionLoggingNeeded%>;
	vgwStaleSessionPurgeInterval = <%=$vgwStaleSessionPurgeInterval%>;
	ipv6Available = <%=$ipv6Available%>;
	
	// For string based assignment using a perl variable, it can't be
	// assigned directly to the value of that perl variable. If we do that,
	// such an assignement will result in an empty assignment due to $lit3 and
	// will lead to a compiler error. So, only for the string based copy from a
	// perl variable, the following check must be done for an empty string and
	// then it should be done as shown below.
	<% if ($certificateFileName eq "") { %>	
	certificateFileName = "";
	<% } else { %>
	certificateFileName = <%=$certificateFileName%>;
	<%}%>
	
	if (certificateFileName == "") {
		// User didn't provide a PEM file. We are going to read 
		// ws-server.pem from the etc directory of the application.
		certificateFileName = ProcessingElement::pe().getApplicationDirectory()
			+ "/etc/ws-server.pem";
	}

	<% if ($certificatePassword eq "") { %>	
	certificatePassword = "";
	<% } else { %>
	certificatePassword = <%=$certificatePassword%>;
	<%}%>	
	
	operatorPhysicalName = getContext().getName();
	//
	// This operator is most likely not going to be in an 
	// UDP parallel region due to the need by the IBM Voice Gateway's 
	// need to connect to a single URL (machine name and port).
	// So, this variable here may not carry much value.
	udpChannelNumber = getContext().getChannel();
	
	SPLAPPTRC(L_ERROR, 
		"Operator " <<
		operatorPhysicalName <<
		"-->Channel " << boost::to_string(udpChannelNumber) <<
		". Following are the user configured operator parameters: "
		"tlsPort=" << tlsPort <<
		", certificateFileName=" << certificateFileName <<
		", certificatePassword length=" << certificatePassword.length() <<
		", nonTlsEndpointNeeded=" << nonTlsEndpointNeeded <<
		", nonTlsPort=" << nonTlsPort <<
		", initDelay=" << initDelay <<
		", vgwLiveMetricsUpdateNeeded=" << vgwLiveMetricsUpdateNeeded <<
		", websocketLoggingNeeded=" << websocketLoggingNeeded <<
		", vgwSessionLoggingNeeded=" << vgwSessionLoggingNeeded <<
		", vgwStaleSessionPurgeInterval=" << vgwStaleSessionPurgeInterval <<
		", ipv6Available="  << ipv6Available, "constructor");	
	
	tlsEndpointStarted = false;
	nonTlsEndpointStarted = false;
	boostAsioServiceRunning = false;
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
    // Finalization code goes here
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
    // Notifies that all ports are ready. No tuples should be submitted before
    // this. Source operators can use this method to spawn threads.
	//
	// Update the operator metric only if the user asked for a live update.
	if (vgwLiveMetricsUpdateNeeded == true) {
		// These are one time metrics that will not change during the life of an operator.
		nTlsPortMetric->setValueNoLock(tlsPort);
		nNonTlsPortNeededMetric->setValueNoLock(nonTlsEndpointNeeded);
		nNonTlsPortMetric->setValueNoLock(nonTlsPort);
	}	
	
	//
	// This is a source operator. Let us create a thread.
	createThreads(1); // Create source thread
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
	// As this operator is about to be shutdown, we will tell the 
	// WebSocket++ endpoints not to accept any more new client connections.
	if (tlsEndpointStarted == true) {
		endpoint_tls.stop_listening();
	}
	
	if (nonTlsEndpointStarted == true) {
		endpoint_plain.stop_listening();
	}

	// We must properly close the client connections that are currently active.
	// That will allow them to be closed normally on their end. Otherwise, clients will end up
	// with limbo (dangling) connections which will lead to unnecessary broken TCP or
	// unclean disconnect or timeouts in the remote end.
	// In addition, it also causes undesirable behaviors by not cleanly terminating the
	// asio run loop in the process method below.
	// So, we must go through the client connections map and 
	// close such existing active client connections in a proper way.
	// This will initiate the WebSocket closing handshake for 
	// these active client connections.
	con_map::iterator it = client_connections_map.begin();

	while (it != client_connections_map.end()) {
		websocketpp::connection_hdl hdl = it->first;
		connection_metadata & con_metadata = it->second;
		
		// Properly close the client connection now.
		std::string closeReason =
			"Normal close by streamsx.sttgateway due to the shutdown of the IBMVoiceGatewaySource operator.";
		websocketpp::lib::error_code ec;

		// This connection closing technique is discussed in these URLs:
		// https://stackoverflow.com/questions/25260852/shut-down-websocket-connection
		// https://github.com/zaphoyd/websocketpp/issues/803
		// https://mayaposch.wordpress.com/2015/09/16/creating-a-websocket-server-with-websocket/
		if(con_metadata.isTlsConnection == true) {
			endpoint_tls.close(hdl, websocketpp::close::status::normal,
				closeReason, ec);
		} else { 
			endpoint_plain.close(hdl, websocketpp::close::status::normal,
				closeReason, ec);
		}

		it++;
	}
	
	// We have to wait for the Boost ASIO run loop to end.
	// Depending on the number of WebSocket connections active at this time,
	// it will take several seconds for that run loop to complete doing its
	// internal cleanup of such connections. If we go ahead and exit this method to 
	// stop this operator without waiting for that run loop thread to complete, 
	// it will most likely cause an error if this operator is restarted immediately.
	// That error would look like this:
	//
	//  CDISR5030E: An exception occurred during the execution of the 
	// VgwDataRouterSource operator. The exception is: Underlying Transport Error
	//
	// The reason for that error: Even if we exit this method, the Boost ASIO
	// run loop is still running and doing its work to clean up all its 
	// connections before closing and releasing the WebSocket server's  
	// port (TLS and/or non-TLS). So let us wait here for a maximum of 
	// three minutes or until the Boost ASIO service stops running whichever
	// occurs first.
	// 
	// This technique to wait for the ASIO run method to end is discussed here.
	// https://groups.google.com/g/websocketpp/c/rvBcIJ940Bc
	//
	SPL::int32 timerCount = 0;
	
	while(boostAsioServiceRunning == true && timerCount <= 18) {
		// Wait for 10 seconds.
		SPL::Functions::Utility::block(10.0);
		// We will do this wait upto 3 minutes.
		// i.e. 18 times each with a 10 seconds wait.
		timerCount++;
	}
	
	// This operator is being shutdown now.
	// We can empty the following containers.
	client_connections_map.clear();
	vgw_session_id_map.clear();
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx)
{
	// If the user provided an initDelay parameter value,
	// then, we will do a one time wait here before doing anything else.
	if (initDelay > 0.0) {
		SPL::Functions::Utility::block(initDelay);
	}
	
	// Initialize this value to current time.
	// This is mainly used inside the on_message method to
	// remove any stale VGW sessions.
	timeOfPreviousStaleSessionRemoval = 
		SPL::Functions::Time::getSeconds(SPL::Functions::Time::getTimestamp());
	
	// Initialize this source operator's custom metrics variables.
	nVoiceCallsProcessed = 0;
	nSpeechDataBytesReceived = 0;
	nOutputTuplesSent = 0;
	
	// A typical implementation will loop until shutdown.
	// In the code below, boost ASIO run method will block forever until
	// the server socket is closed. We will take measures for closing the
	// server socket in the prepareToShutdown method above when the operator is 
	// about to be shutdown. So, we need not go in a while loop as commonly
	// done in other source operators.
	// Hence, I commented out the following while loop line and its
	// corresponding close brace at the end of the coce block below.
	//
	// while(!getPE().getShutdownRequested()) {
		// Set up an external io_service to run both endpoints on. This is not
		// strictly necessary, but simplifies thread management a bit.
		boost::asio::io_service ios;

		// If the user opted for an additional non-TLS (plain) 
		// Websocket endpoint, let us create that as well.
		// This plain insecure endpoint is here for a very 
		// remote possibility of this getting used for any future use cases.
		// It is fine to provide both plain and TLS ports as it is
		// supported by the WebSocket++ library.
		if (nonTlsEndpointNeeded == true) {
			// Set up a plain endpoint without TLS.
			// Initialize asio with our external io_service rather than an internal one.
			endpoint_plain.init_asio(&ios);
			endpoint_plain.set_open_handler(bind(&MY_OPERATOR::on_open_non_tls,this,::_1));
			endpoint_plain.set_message_handler(
				bind(&MY_OPERATOR::on_message<server_plain>,this,&endpoint_plain,::_1,::_2));
			endpoint_plain.set_close_handler(bind(&MY_OPERATOR::on_close,this,::_1));
			
			// https://docs.websocketpp.org/reference_8logging.html
			// Set the logging policy as needed
			// Turn off or turn on selectively all the Websocket++ access interface and 
			// error interface logging channels. Do this based on how the user has
			// configured this operator.
			if (websocketLoggingNeeded == true) {
				// Enable certain error logging channels and certain access logging channels.
				endpoint_plain.set_access_channels(websocketpp::log::alevel::frame_header);
				endpoint_plain.set_access_channels(websocketpp::log::alevel::frame_payload);				
			} else {
				// Turn off both the access and error logging channels completely.
				endpoint_plain.clear_access_channels(websocketpp::log::alevel::all);
				endpoint_plain.clear_error_channels(websocketpp::log::elevel::all);
			}
			
			// Plain (non-TLS) endpoint listens on its own port.
			// Most of the modern day Linux machines will have an ipv6 protocol stack. 
			// By default, WebSocket++ listens in a dual stack ipv4/ipv6 mode. 
			// It will fail with the following error if an ipv6 stack is not available. 
			// "asio listen error: system:97 (Address family not supported by protocol)"
			// If it is an issue to enable ipv6 on a Linux macchine, a quick fix is to 
			// use one of the endpoint::listen overloads that lets us specify 
			// an address family to listen on and manually select to listen only via ipv4.
			// This solution is suggested in these URLs:
			// https://groups.google.com/forum/#!topic/websocketpp/-BB_Kr_rFPg
			// https://github.com/zaphoyd/websocketpp/issues/674
			if (ipv6Available == true) {
				endpoint_plain.listen(nonTlsPort);
			} else {
				// We must use only the ipv4 protocol stack in this case.
				endpoint_plain.listen(boost::asio::ip::tcp::v4(), nonTlsPort);
			}
			
			endpoint_plain.start_accept();
			nonTlsEndpointStarted = true;
		}

		// Set up a TLS endpoint at all times since the 
		// IBM Voice Gateway product will only use a secure endpoint.
		endpoint_tls.init_asio(&ios);
		endpoint_tls.set_open_handler(bind(&MY_OPERATOR::on_open_tls,this,::_1));
		endpoint_tls.set_message_handler(
			bind(&MY_OPERATOR::on_message<server_tls>,this,&endpoint_tls,::_1,::_2));
		endpoint_tls.set_close_handler(bind(&MY_OPERATOR::on_close,this,::_1));
		// TLS endpoint has an extra handler for the tls init
		endpoint_tls.set_tls_init_handler(bind(&MY_OPERATOR::on_tls_init,this,::_1));

		if (websocketLoggingNeeded == true) {
			// Enable certain error logging channels and certain access logging channels.
			endpoint_tls.set_access_channels(websocketpp::log::alevel::frame_header);
			endpoint_tls.set_access_channels(websocketpp::log::alevel::frame_payload);
		} else {
			// Turn off both the access and error logging channels completely.
			endpoint_tls.clear_access_channels(websocketpp::log::alevel::all);
			endpoint_tls.clear_error_channels(websocketpp::log::elevel::all);
		}		
		
		// TLS endpoint listens on a different port.
		// Please refer to the detailed comments in the endpoint_plain.listen 
		// code block above about this ipv6 availability check.
		if (ipv6Available == true) {
			endpoint_tls.listen(tlsPort);
		} else {
			// We must use only the ipv4 protocol stack in this case.
			endpoint_tls.listen(boost::asio::ip::tcp::v4(), tlsPort);
		}
		
		endpoint_tls.start_accept();
		tlsEndpointStarted = true;
		boostAsioServiceRunning = true;

		// Start the Boost ASIO io_service run loop that can handle both endpoints.
		// This will block until the server socket gets closed.
		// For additional details, please refer to the commentary and 
		// logic in the prepareToShutdown method
		ios.run();
		boostAsioServiceRunning = false;
	// }
}

// This method sets up the TLS for a given client connection handle.
// WebSocket++ library calls this handler ahead of time before a
// new TLS client attempts to connect. It prepares a TLS context
// ahead of time and keeps a spare one to be assigned to the next 
// arriving new WebSocket or a regular https client (wss or https).
// When such a new TLS client connects here, it will be using that
// spare handle throughout its connected life.
MY_OPERATOR::context_ptr MY_OPERATOR::on_tls_init(websocketpp::connection_hdl hdl) {
	bool vgwSessionLoggingDone = false;
	
	if (vgwSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, "on_tls_init called with hdl: " << hdl.lock().get(), "on_tls_init");
		vgwSessionLoggingDone = true;
	}
	
	if (vgwSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO, "on_tls_init called with hdl: " << hdl.lock().get(), "on_tls_init");
	}
	
	// TIP: If we want to know which TLS version gets negotiated between the
	// client and the server, we can run this command from a client machine:
	//
	// openssl s_client -connect TLSHost:port
	// openssl s_client -connect b0513:8443
	//
	// You can read more about that command in this URL:
	// https://security.stackexchange.com/questions/100029/how-do-we-determine-the-ssl-tls-version-of-an-http-request
	//
	// We will configure the boost asio server to support only the tlsv12 protocol.
	// We can disable the other SSL, TLS protocol versions in order to 
	// strengthen the security.
	// You can read more details about this from here.
	// https://stackoverflow.com/questions/47096415/how-to-make-boostasio-ssl-server-accept-both-tls-1-1-and-tls-1-2/47097088
	// https://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ssl__context.html
	// https://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/ssl__context/method.html
	//
	// As shown in the URL above, we can use one of several TLS context methods such as
	// tlsv1, tlsv1_server, tlsv11, tlsv11_server, tlsv12, tlsv12_server. Using one of these
	// options will start only a server supporting that TLS version. Alternatively, we can simply
	// use tls_server which will allow all the versions i.e. v1, v11 and v12. Then, we can apply the 
	// no_tlsxxx flags to disable a particular tls version as needed.
	context_ptr ctx(
		new boost::asio::ssl::context(boost::asio::ssl::context::tls_server));

	try {
		// We will support only tlsv1.2. Let us disable all the other older 
		// tls versions including the very old ssl v2 and v3 protocols.
		ctx->set_options(
				boost::asio::ssl::context::default_workarounds
						| boost::asio::ssl::context::no_sslv2
						| boost::asio::ssl::context::no_sslv3
						| boost::asio::ssl::context::no_tlsv1
						| boost::asio::ssl::context::no_tlsv1_1
						| boost::asio::ssl::context::single_dh_use);
		ctx->set_password_callback(bind(&MY_OPERATOR::get_private_key_password, this));
		// Let us now load the server's private key and 
		// public certificate holding PEM file.
		ctx->use_certificate_chain_file(certificateFileName.c_str());
		ctx->use_private_key_file(certificateFileName.c_str(), boost::asio::ssl::context::pem);
	} catch (std::exception& e) {
    	std::cout << "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) << 
			"-->" << e.what() << std::endl;
		
		throw std::runtime_error(
			std::string("IBMVoiceGatewaySource_cpp.cgt: Exception in on_tls_init: ") +
			e.what() +
			". Reason for this error could be an invalid wss, https URL or a " +
			"missing server certificate file. Please check.");
	}
    
	return ctx;
}

// When a client establishes a new non_tls Websocket connection, this callback method is run.
void MY_OPERATOR::on_open_non_tls(websocketpp::connection_hdl hdl) {
	// Let us redirect this to the common on_open handler by
	// setting the second argument to false to indicate that
	// it is a non_tls WebSocket connection from a client.
	on_open(hdl, false);
} // End of on_open_non_tls

// When a client establishes a new TLS Websocket connection, this callback method is run.
void MY_OPERATOR::on_open_tls(websocketpp::connection_hdl hdl) {
	// Let us redirect this to the common on_open handler by
	// setting the second argument to true to indicate that
	// it is a TLS WebSocket connection from a client.
	on_open(hdl, true);
} // End of on_open_tls.

// This is a common on_open handler for both the non_tls and TLS new client connections.
void MY_OPERATOR::on_open(websocketpp::connection_hdl hdl, bool isTlsConnection) {
	bool vgwSessionLoggingDone = false;
	
	if (vgwSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, "on_open called for hdl: " << 
			hdl.lock().get(), "on_open");
		vgwSessionLoggingDone = true;
	}
	
	if(vgwSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO, "on_open called for hdl: " << 
			hdl.lock().get(), "on_open");
	}

	// Add this newly opened client connection to the associative container.
	connection_metadata con_metadata;
	con_metadata.isTlsConnection = isTlsConnection;
	con_metadata.vgwSessionStatus = VGW_OPENED_A_WS_CONNECTION;
	con_metadata.vgwSessionStartTime = 
		SPL::Functions::Time::getSeconds(SPL::Functions::Time::getTimestamp());
	con_metadata.speechPacketsReceivedCnt = 0;
	con_metadata.speechDataBytesReceived = 0;
	con_metadata.vgwSessionId = "";
	con_metadata.vgwSIPCallID = "";
	con_metadata.vgwParticipantURI = "";
	con_metadata.vgwTenantID = "";
	con_metadata.vgwSIPToURI = "";
	con_metadata.vgwIsCaller = false;
	con_metadata.vgwVoiceChannelNumber = 0;
	client_connections_map[hdl] = con_metadata;
}

// This recursive templatized function with c++11 syntax is from the 
// C++ boost Q&A (how-to) technical discussion here:
// https://stackoverflow.com/questions/48407925/boostproperty-treeptree-accessing-arrays-first-complex-element?noredirect=1&lq=1
// It helps us to directly index an element in a JSON array sent by the IBM Voice Gateway.
// To use c++11 syntax in a Streams C++ operator, it is required to add this
// sc (Streams Compiler) option: --c++std=c++11
template <typename Tree>
Tree query(Tree& pt, typename Tree::path_type path) {
    if (path.empty())
        return pt;

    auto const head = path.reduce();

    auto subscript = head.find('[');
    auto name      = head.substr(0, subscript);
    auto index     = std::string::npos != subscript && head.back() == ']'
        ? std::stoul(head.substr(subscript+1))
        : 0u;

    auto matches = pt.equal_range(name);
    if (matches.first==matches.second)
        throw std::out_of_range("name:" + name);

    for (; matches.first != matches.second && index; --index)
        ++matches.first;

    if (index || matches.first==matches.second)
        throw std::out_of_range("index:" + head);

    return query(matches.first->second, path);
}

// The shared on_message handler takes a template parameter so the function can
// resolve any endpoint dependent types like message_ptr or connection_ptr
template <typename EndpointType>
void MY_OPERATOR::on_message(EndpointType* s, websocketpp::connection_hdl hdl,
    typename EndpointType::message_ptr msg) {
	
	if (vgwSessionLoggingNeeded == true) {
		SPLAPPTRC(L_INFO, "on_message called with hdl: " << hdl.lock().get()
			<< " with a message size of: " << msg->get_payload().size() << " bytes.", "on_message");
	}
	
	connection_metadata con_metadata;
	
	try {
		// Get the metadata details for this connection handle from our client connections map.
		con_metadata = get_con_metadata_from_hdl(hdl);
	} catch (const std::invalid_argument & e) {
		SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) << 
			"-->hdl=" << hdl.lock().get() <<
			".-->X1 Unable to get con_metadata-->" << e.what(), "on_message");
		return;
	} catch (...) {
		SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) << 
			"-->hdl=" << hdl.lock().get() <<
			".-->X1 Unable to get con_metadata-->Other exception occurred.", "on_message");
		return;
	}
	
	// IBM Voice Gateway will send messages via a given client connection
	// either with textual data or with binary data. 
	// Textual data will be sent at the time of the session start and 
	// session end. At all other times, it will send binary information 
	// containing the raw speech data. 
	// Let us first determine if the received message contains textual or binary data.
	if (msg->get_opcode() == websocketpp::frame::opcode::text) {
		// Create a boost property tree root
		std::string action = "";
		pt::ptree root;
		std::stringstream ss;
		ss << msg->get_payload();
		
		try {
			// Load the json data in the boost ptree
			pt::read_json(ss, root);
		} catch (std::exception const& e) {
			if (vgwSessionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) <<
					"-->X1 Received text content is in an unexpected format: " <<
					msg->get_payload() << 
					". So, this message from the IBM Voice Gateway is ignored when " <<
					"the current session status is " << con_metadata.vgwSessionStatus <<
					".", "on_message");
			}
			
			return;
		}
		
		// Read the action element.
		try {
			action = query(root, "action").get_value<std::string>();
		} catch (std::exception const& e) {
			if (vgwSessionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) <<
					"-->X1 JSON parsing error when reading the field : " << e.what() <<
					", IBM Voice Gateway sent this message: " << msg->get_payload(), "on_message");
			}
			
			// Without the action field, we can't do anything.
			return;
		}
		
		// Let us check if it is start session or end session message.
		if (con_metadata.vgwSessionStatus == VGW_OPENED_A_WS_CONNECTION) {
			// With this particular session status, the next text based message allowed 
			// for the IBM Voice Gateway is for it to send us the start session message.
			// Let us ensure that is the case here.
			// A start session message from the IBM Voice Gateway will look like this.
			/*
			// ===========================================================
			{
			  "action": "start",
			  "siprecMetadata": {
			      "vgwSessionID" : "8443572187904004@192.168.208.5",
			      "vgwSIPCallID" : "8443572187904004@192.168.208.5",
			      "vgwParticipantURI" : "sip:alice@10.10.10.7",
			      "vgwIsCaller" : true
			  }
			}
			// ===========================================================
			*/
			if (action == "start") {
				// It is a start session message sent by the IBM Voice Gateway.
				// Parse the metadata from the received JSON and 
				// populate our internal data structure.
				//
				// Look for vgwSessionId
				try {
					// This is an important metadata that identiies
					// every unique voice call. It must be present.
					con_metadata.vgwSessionId = query(root, 
						"siprecMetadata.vgwSessionID").get_value<std::string>();
				}  catch (std::exception const& e) {
					if (vgwSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) <<
							"-->X1 JSON parsing error when reading the field : " << e.what() <<
							", IBM Voice Gateway sent this message: " << msg->get_payload(), "on_message");
					}
					
					// An important field is not present.
					return;
				}
				
				if (con_metadata.vgwSessionId == "") {
					// We can't do much with an empty vgwSessionId.
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) <<
						"-->X1 JSON start session message from the IBM Voice Gateway doesn't have a non-empty vgwSessionId field. So, ignoring this start session message." <<
						", IBM Voice Gateway sent this message: " << msg->get_payload(), "on_message");
					return;
				}

				// Look for vgwIsCaller
				try {
					// This is also an important metadata that identiies
					// whether this connection (channel) carries the 
					// customer's (a.k.a Caller) speech rather than the agent's speech.
					con_metadata.vgwIsCaller = query(root, 
						"siprecMetadata.vgwIsCaller").get_value<bool>();
				}  catch (std::exception const& e) {
					// We can't do much without knowing about this important field.
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) <<
						"-->X1 JSON start session message from the IBM Voice Gateway doesn't have the vgwIsCaller field. So, ignoring this start session message." <<  
						", IBM Voice Gateway sent this message: " << msg->get_payload(), "on_message");
					return;
				}
								
				// Look for vgwSIPCallID
				try {
					// It is fine even if this field is not present in the JSON message.
					con_metadata.vgwSIPCallID = query(root, 
						"siprecMetadata.vgwSIPCallID").get_value<std::string>();
				}  catch (std::exception const& e) {
					if (vgwSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) <<
							"-->X1 JSON parsing error when reading the field : " << e.what() <<
							", IBM Voice Gateway sent this message: " << msg->get_payload(), "on_message");
					}					
				}

				// Look for vgwParticipantURI
				try {
					// It is fine even if this field is not present in the JSON message.
					con_metadata.vgwParticipantURI = query(root, 
						"siprecMetadata.vgwParticipantURI").get_value<std::string>();
				}  catch (std::exception const& e) {
					if (vgwSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) <<
							"-->X1 JSON parsing error when reading the field : " << e.what() <<
							", IBM Voice Gateway sent this message: " << msg->get_payload(), "on_message");
					}					
				}

				// Look for vgwTenantID
				try {
					// It is fine even if this field is not present in the JSON message.
					con_metadata.vgwTenantID = query(root, 
						"siprecMetadata.vgwTenantID").get_value<std::string>();
				}  catch (std::exception const& e) {
					if (vgwSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) <<
							"-->X1 JSON parsing error when reading the field : " << e.what() <<
							", IBM Voice Gateway sent this message: " << msg->get_payload(), "on_message");
					}					
				}

				// Look for vgwSIPToURI
				try {
					// It is fine even if this field is not present in the JSON message.
					con_metadata.vgwSIPToURI = query(root, 
						"siprecMetadata.vgwSIPToURI").get_value<std::string>();
				}  catch (std::exception const& e) {
					if (vgwSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) <<
							"-->X1 JSON parsing error when reading the field : " << e.what() <<
							", IBM Voice Gateway sent this message: " << msg->get_payload(), "on_message");
					}					
				}
								
				// If we reached this far, then we can give an 
				// affirmative response back to the IBM Voice Gateway for 
				// its session start message.
				try {
					std::string response = "{\"state\": \"listening\"}";
					s->send(hdl, response, msg->get_opcode());
				} catch (websocketpp::exception const & e) {
					SPLAPPTRC(L_ERROR, "Failure while sending the affirmative " <<
						"response to the IBM Voice Gateway for its start session message. Error: " << 
						"(" << e.what() << ")", "on_message");
					// In this case, IBM Voice Gateway can try to send the "Start Session" message again.
					return;
			    }
				
				// At this point, we can claim that the IBM Voice Gateway 
				// started an STT session. So, we can transition this connection's 
				// status to the next logical state.
				con_metadata.vgwSessionStatus = VGW_STARTED_AN_STT_SESSION;
				// Let us store the call start date time string represented as system/wall clock time.
				con_metadata.callStartDateTime = 
					SPL::Functions::Time::ctime(SPL::Functions::Time::getTimestamp());
				// Update it in the client connections map.
				client_connections_map[hdl] = con_metadata;
				
				// At this time, we can store the phone number 
				// (agent or caller) belonging to this voice channel to be
				// returned later when and if the application (i.e. user of this operator) 
				// queries for it via this operator's custom output function.
				//
				// We have a map where the agent and caller phone numbers of a given
				// call session id are stored. 
				//
				// Key: vgeSessionId_vgwIsCaller
				// Value: Phone Number
				std::string key = con_metadata.vgwSessionId + std::string("_") + 
					boost::to_string(con_metadata.vgwIsCaller);
				vgwSessionPhoneNumbersMap[key] = con_metadata.vgwParticipantURI;
				
				if (vgwSessionLoggingNeeded == true) {
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) <<
						"-->X1 Received and processed a start session message for the vgwSessionId " <<
						con_metadata.vgwSessionId <<
						", vgwIsCaller=" << con_metadata.vgwIsCaller << 
						", vgwSIPCallID=" << con_metadata.vgwSIPCallID <<
						", vgwParticipantURI=" << con_metadata.vgwParticipantURI <<
						", vgwTenantID=" << con_metadata.vgwTenantID <<
						", vgwSIPToURI=" << con_metadata.vgwSIPToURI << 
						".", "on_message");
				}					

				return;
			} else {
				if (vgwSessionLoggingNeeded == true) {
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) <<
						"-->X1 Received an invalid action: " <<
						action << 
						". So, this message from the IBM Voice Gateway is ignored when " <<
						"the current session status is VGW_OPENED_A_WS_CONNECTION. " <<
						"Only 'action':'start' is allowed at this time. " <<
						", IBM Voice Gateway sent this message: " << msg->get_payload(),
						"on_message");
				}					
				
				return;
			} // End of if (action == "start")
		} // End of if (con_metadata.vgwSessionStatus == VGW_OPENED_A_WS_CONNECTION)
		
		if (con_metadata.vgwSessionStatus == VGW_STARTED_AN_STT_SESSION) {
			// With this particular session status, the next text based message allowed 
			// for the IBM Voice Gateway is for it to send us the stop session message.
			// Let us ensure that is the case here.
			// A stop session message from the IBM Voice Gateway will look like this.
			/*
			// ===========================================================
			{
			  "action": "stop",
			}
			// ===========================================================
			*/
			// **** IMPORTANT CHANGE ****
			// Jan/15/2021: Senthil completely deactivated the entire logic in this
			// if block. He moved the exact same logic to the on_close method to address
			// problems in not being to send the EOCS signals consistently and reliably.
			// Please read the commentary in the on_close method to understand the
			// main reason behind this change.
			boolean processStopActionMessage = false;
			
			if (action == "stop") {
				if(processStopActionMessage == true) {
					// Update this metric.
					nSpeechDataBytesReceived += (uint64_t)con_metadata.speechDataBytesReceived;
					nOutputTuplesSent += (uint64_t)con_metadata.speechPacketsReceivedCnt;
	
					// It is a stop session message sent by the IBM Voice Gateway.
					// We can delete this connection's meta data cached in our
					// client connection map.
					if (vgwSessionLoggingNeeded == true) {
						SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) <<
							"-->X3 Received and processed a stop session message for the vgwSessionId " << 
							con_metadata.vgwSessionId << 
							", vgwIsCaller=" << con_metadata.vgwIsCaller << 
							", vgwVoiceChannelNumber=" << con_metadata.vgwVoiceChannelNumber <<
							".", "on_message");
					}					
	
					// There may be more than one channel in the voice call for this
					// vgwSessionId. All we know is that this particular channel (i.e. connection)
					// that we have here is ending its STT session. We will go ahead and send an
					// "End of Voice Call" signal to the downstream operator in order for it to 
					// free up the necessary things handling this speaker of a given 
					// voice call i.e. vgwSessionId_vgwVoiceChannelNumber combo. 
					// If this happens to be the very last channel doing the "End session" in a 
					// multi-channel voice call, we will also do the following cleanup.
					// [Most of the voice calls will have two different channels: 
					//  one for the customer speech and the other for the agent speech.]
					bool vgwSessionIdFoundInMap = 
						vgw_session_id_map.find(con_metadata.vgwSessionId) != vgw_session_id_map.end();
					
					if (vgwSessionIdFoundInMap == true) {
						// Send the "End of Voice Call" signal now for this
						// vgwSessionId_vgwVoiceChannelNumber combo.
						OPort0Type oTuple;
						oTuple.set_vgwSessionId(con_metadata.vgwSessionId);
						oTuple.set_isCustomerSpeechData(con_metadata.vgwIsCaller);
						oTuple.set_vgwVoiceChannelNumber(con_metadata.vgwVoiceChannelNumber);
						oTuple.set_endOfCallSignal(true);
						submit(oTuple, 0);
						
						if (vgwSessionLoggingNeeded == true) {
							SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
								"-->Channel " << boost::to_string(udpChannelNumber) <<
								"-->X3 Sent an 'End of Voice Call' signal for vgwSessionId=" << 
								con_metadata.vgwSessionId << 
								", vgwVoiceChannelNumber=" <<
								con_metadata.vgwVoiceChannelNumber << ".", "on_message");
						}					
	
						// Make the adjustment by removing the 
						// last entry in the list being held inside this map. 
						vgw_session_id_map[con_metadata.vgwSessionId].pop_back();
						
						if (vgw_session_id_map[con_metadata.vgwSessionId].size() <= 0) {
							// There are no more active channels for this vgwSessionId.
							// This channel is the very last one in this voice call to end the session.
							// So, let us remove it from the map.
							vgw_session_id_map.erase(con_metadata.vgwSessionId);
	
							// A voice call is fully completed now. Update this metric.
							nVoiceCallsProcessed++;
							// Update the operator metric only if the user asked for a live update.
							if (vgwLiveMetricsUpdateNeeded == true) {
								nVoiceCallsProcessedMetric->setValueNoLock(nVoiceCallsProcessed);
								nSpeechDataBytesReceivedMetric->setValueNoLock(nSpeechDataBytesReceived);
								nOutputTuplesSentMetric->setValueNoLock(nOutputTuplesSent);
							}						
						} // End of if (vgw_session_id_map[con_metadata.vgwSessionId] <= 0)
					} // End of if (vgwSessionIdFoundInMap == true)
	
					if (vgwStaleSessionPurgeInterval > 0) {
						// PERIODIC STALE SESSION AND STALE CONNECTION REMOVAL.
						// Do this only if the user provided a non-zero purge interval.
						// We should be prepared for a condition where the
						// "Stop STT session" message never arrives for some reason.
						// One reason this can happen is due to an abnormal crash or
						// an abnormal exit/closure on the VGW side of things.
						// In that case, it will leave us with left over map entries.
						// So, we will have to purge those left over map entries.
						// Similarly, any unclosed client connection (which is 
						// extremely rare) will also leave stale entries in the map.
						// We will remove all such things here periodically.
						int64_t currentTimeInSeconds = 
							SPL::Functions::Time::getSeconds(SPL::Functions::Time::getTimestamp());
						
						if (currentTimeInSeconds - timeOfPreviousStaleSessionRemoval >=
							vgwStaleSessionPurgeInterval) {
							// Time elapsed. Time to check for stale entries.
							std::list<std::string> staleList;
							staleList.clear();
									
							// Let us first check inside the VGW session id map.
							for(std::map<std::string, SPL::list<int64_t>>::iterator it = vgw_session_id_map.begin();
								it != vgw_session_id_map.end(); it++) {
								// SPL::list is nothing but an std::vector behind the scenes.
								SPL::list<int64_t> myList = it->second;
								
								// Loop through this list and check every voice channel's start time.
								for(SPL::list<int64_t>::iterator it2 = myList.begin();
									it2 != myList.end(); it2++) {
									if (currentTimeInSeconds - *it2 >=
										vgwStaleSessionPurgeInterval) {
										// This is a stale entry. Store the VGW session id.
										staleList.push_back(it->first);
										break;
									}
								}
							}
							
							// Now, we can remove the stale entries if any.
							for(std::list<std::string>::iterator it = staleList.begin();
								it != staleList.end(); it++) {
								vgw_session_id_map.erase(*it);
								
								if (vgwSessionLoggingNeeded == true) {
									SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
										"-->Channel " << boost::to_string(udpChannelNumber) <<
										"-->X4 Removed a stale VGW session id. " <<
										*it, "on_message");
								}
								
								// Added this logic on Sep/04/2020.
								// Since we know the VGW session id that has gone stale,
								// we can attempt to clean up a few more things on a 
								// best effort basis as shown below.
								//
								// Since this connection has gone stale, we can send an 
								// abnormal, delayed EndOfCall Signal via the output port.
								// That can help the underlying application logic to
								// do its own clean-up and release of the STT engines.
								// Send the "End of Voice Call" signal now for this
								// vgwSessionId_vgwVoiceChannelNumber combo.
								// Send it for voice channel 1 which is an 
								// agent channel most of the time.
								OPort0Type oTuple;
								oTuple.set_vgwSessionId(*it);
								oTuple.set_isCustomerSpeechData(false);
								oTuple.set_vgwVoiceChannelNumber(1);
								oTuple.set_endOfCallSignal(true);
								submit(oTuple, 0);
								// Do the same for voice channel 2 which is a
								// customer channel most of the time.
								oTuple.set_vgwSessionId(*it);
								oTuple.set_isCustomerSpeechData(true);
								oTuple.set_vgwVoiceChannelNumber(2);
								oTuple.set_endOfCallSignal(true);
								submit(oTuple, 0);
								
								// We have a map where the agent and caller phone numbers of a given
								// call session id are stored. Since this call has gone stale,
								// let us remove the corespoding entry from that map.
								//
								// Key: vgeSessionId_vgwIsCaller
								// Value: Phone Number
								// Let us remove the agent's phome first.
								bool vgwIsCaller = false;
								std::string key = *it + std::string("_") + 
									boost::to_string(vgwIsCaller);
								auto it2 = vgwSessionPhoneNumbersMap.find(key);
	
								if (it2 != vgwSessionPhoneNumbersMap.end()) {
									// it2->first has the key of the map and it->second has the value.
									vgwSessionPhoneNumbersMap.erase(it2->first);
								}	
	
								// Let us also try to remove the caller's phone.
								vgwIsCaller = true;
								key = *it + std::string("_") + boost::to_string(vgwIsCaller);
								auto it3 = vgwSessionPhoneNumbersMap.find(key);
	
								if (it3 != vgwSessionPhoneNumbersMap.end()) {
									// it3->first has the key of the map and it->second has the value.
									vgwSessionPhoneNumbersMap.erase(it3->first);
								}	
							} // End of for loop.
							
							std::list<websocketpp::connection_hdl> staleList2;
							staleList2.clear();
							
							// Let us now check the client connections map.
							// Stale entries happening in this map is a rarity just because
							// on_close handler almost always gets invoked during the
							// normal as well as abnormal client connection closures.
							for(con_map::iterator it = client_connections_map.begin();
								it != client_connections_map.end(); it++) {
								connection_metadata cmd = it->second;
								
								if(currentTimeInSeconds - cmd.vgwSessionStartTime > 
									vgwStaleSessionPurgeInterval) {
									// This is a stale entry. Store the connection handle.
									staleList2.push_back(it->first);
									
									// Added this logic on Sep/04/2020.
									// NOTE: We already made an attempt to do this same logic
									// inside the previous for loop. We are doing the same 
									// here again using the connection data. This should not 
									// cause any harm. If a duplicate EOCS is sent from here,
									// the underlying app;ication logic should do the right
									// thing to ignore if that EOCS is redundant.
									//
									// Since this connection has gone stale, we can send an 
									// abnormal, delayed EndOfCall Signal via the output port.
									// That can help the underlying application logic to
									// do its own clean-up and release of the STT engines.
									// Send the "End of Voice Call" signal now for this
									// vgwSessionId_vgwVoiceChannelNumber combo.
									OPort0Type oTuple;
									oTuple.set_vgwSessionId(cmd.vgwSessionId);
									oTuple.set_isCustomerSpeechData(cmd.vgwIsCaller);
									oTuple.set_vgwVoiceChannelNumber(cmd.vgwVoiceChannelNumber);
									oTuple.set_endOfCallSignal(true);
									submit(oTuple, 0);
									
									// Added this logic on Sep/04/2020.
									// We have a map where the agent and caller phone numbers of a given
									// call session id are stored. Since this leg of that call has gone stale,
									// let us remove the corespoding entry from that map.
									//
									// Key: vgeSessionId_vgwIsCaller
									// Value: Phone Number
									std::string key = cmd.vgwSessionId + std::string("_") + 
										boost::to_string(cmd.vgwIsCaller);
									auto it = vgwSessionPhoneNumbersMap.find(key);
	
									if (it != vgwSessionPhoneNumbersMap.end()) {
										// it->first has the key of the map and it->second has the value.
										vgwSessionPhoneNumbersMap.erase(it->first);
									}	
								} // End of if(currentTimeInSeconds - cmd.vgwSessionStartTime > 
							} // End of  for loop.
		
							int32_t stale2RemovedCnt = 0;
							// Now, we can remove the stale entries if any.
							for(std::list<websocketpp::connection_hdl>::iterator it = staleList2.begin();
								it != staleList2.end(); it++) {
								client_connections_map.erase(*it);
								stale2RemovedCnt++;
							}
		
							if (vgwSessionLoggingNeeded == true && stale2RemovedCnt > 0) {
								SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
									"-->Channel " << boost::to_string(udpChannelNumber) <<
									"-->X4 Removed a few stale client connection handles. Removed count=" <<
									stale2RemovedCnt, "on_message");
							}
							
							// Set it to the current time so that we can do our next 
							// stale sesion data removal at the required time interval.
							timeOfPreviousStaleSessionRemoval = currentTimeInSeconds;
						}
					} // End of if (vgwStaleSessionPurgeInterval > 0)
				} else {
					if (vgwSessionLoggingNeeded == true) {
						SPLAPPTRC(L_INFO, "Operator " << operatorPhysicalName <<
							"-->Channel " << boost::to_string(udpChannelNumber) <<
							"-->X501 Received an 'action':'stop' message and ignored it " << 
							"due to the deactivated code block. This is just an INFO and not an error.",
							"on_message");						
					}
				} // End of if(processStopActionMessage == true)

				return;
			} else {
				if (vgwSessionLoggingNeeded == true) {
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) <<
						"-->X3 Received an invalid action: " <<
						action << 
						". So, this message from the IBM Voice Gateway is ignored when " <<
						"the current session status is VGW_STARTED_AN_STT_SESSION. " <<
						"Only 'action':'stop' is allowed at this time." <<
						", IBM Voice Gateway sent this message: " << msg->get_payload(),
						"on_message");
				}					
				
				return;
			} // End of if (action == "stop")
		} // End of if (con_metadata.vgwSessionStatus == VGW_STARTED_AN_STT_SESSION)
		
		return;
	} // End of if (msg->get_opcode() == websocketpp::frame::opcode::text)
	
	// Check if the IBM Voice Gateway sent us binary speech data
	// It is very important to note that the IBM Voice Gateway will keep
	// sending the speech data of the caller and the agent on two 
	// voice channels i.e. one for the caller and the other for the agent.
	// Irrespective of those two speakers talk or remain silent during the
	// call, their assigned voice channel will always carry some binary
	// data. That means, there is no way to know who is currently
	// talking. This constraint limits us from sending only one of the
	// channel's data to a single STT engine at any given time.
	// Instead, this constraint forces us to dedicate a single STT engine
	// per voice channel in a given voice call and keep sending the
	// data being received on that channel continuously to that
	// dedicated STT engine irrespective of whether that channel carries
	// silence or active speech data. In summary, we will need two
	// STT engines to do the Speech To Text for every ongoing voice call.
	if (msg->get_opcode() == websocketpp::frame::opcode::binary) {
		// IBM Voice Gateway can send binary speech after it has 
		// already started a session with us by sending its voice call meta data.
		if (con_metadata.vgwSessionStatus == VGW_STARTED_AN_STT_SESSION) {
			// With this particular session status, we can accept the
			// binary data coming from the IBM Voice Gateway.
			// We will receive the binary data and send it on this
			// operator's first output port for consumption by the other
			// downstream operators in the application flow graph.
			//
			// Update some of the counters we maintain in the con_metadata.
			con_metadata.speechPacketsReceivedCnt++;
			int32_t payloadSize = msg->get_payload().size();
			con_metadata.speechDataBytesReceived += payloadSize;
						
			// If we received the very first speech packet for the given
			// vgwSessionId via a given connection_hdl, that means the
			// speech data has started arriving actively on this channel (i.e. connection).
			// So, increment the map value to indicate the number of active 
			// speech channels for the given vgwSessionId.
			if (con_metadata.speechPacketsReceivedCnt == 1) {
				bool vgwSessionIdFoundInMap = 
					vgw_session_id_map.find(con_metadata.vgwSessionId) != vgw_session_id_map.end();
				
				if (vgwSessionIdFoundInMap == false) {
					// This vgwSessionId is not there in this map.
					// So, insert it freshly now.
					// SPL::list is nothing but an std::vector behind the scenes.
					SPL::list<int64_t> myList;
					myList.push_back(con_metadata.vgwSessionStartTime);
					vgw_session_id_map[con_metadata.vgwSessionId] = myList;
					// This is the first voice channel in which the speech data bytes
					// have started arriving for this particular VGW session id.
					con_metadata.vgwVoiceChannelNumber = 1;
				} else {
					// This vgwSessionId is already present in the map.
					// So, add a new entry to the list.
					vgw_session_id_map[con_metadata.vgwSessionId].push_back(
						con_metadata.vgwSessionStartTime);
					// This is the second voice channel in which the speech data bytes
					// have started arriving for this particular VGW session id.
					con_metadata.vgwVoiceChannelNumber = 2;
				}
				
				if (vgwSessionLoggingNeeded == true) {
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) <<
						"-->X2 Received the very first speech data packet. vgwSessionId=" << 
						con_metadata.vgwSessionId << ", vgwVoiceChannelNumber=" << 
						con_metadata.vgwVoiceChannelNumber <<
						", vgwIsCaller=" << con_metadata.vgwIsCaller, "on_message");
				}
			} // End of if (con_metadata.speechPacketsReceivedCnt == 1)

			// Update it in the client connections map.
			client_connections_map[hdl] = con_metadata;
			
			// In WebSocket++, payload is in std::string format for both
			// text and binary data. So, we can get the binary buffer from
			// that string payload. This idea is discussed in this URL:
			// https://github.com/zaphoyd/websocketpp/issues/412
			const char* payload = msg->get_payload().data();
			uint8_t const* payloadBuffer = 
				reinterpret_cast<const uint8_t*>(payload);
			// Let us create an output tuple and send it out.
			// Create an SPL blob type.
			SPL::blob speechBlob;
			// This transfers (copies) the payload buffer into the 
			// internal buffer hold by the blob. 
			// The blob owns the copied data in memory.
			speechBlob.setData((unsigned char*)payloadBuffer, (uint64_t)payloadSize);
			OPort0Type oTuple;
			oTuple.set_speech(speechBlob);
			oTuple.set_endOfCallSignal(false);
			
			// Now let us set any attributes that the caller of this operator is trying to
			// assign through this operator's output functions.
			<% 
			  my $oport = $model->getOutputPortAt(0); 
			  foreach my $attribute (@{$oport->getAttributes()}) { 
				  my $name = $attribute->getName(); 
				  my $paramValues = $attribute->getAssignmentOutputFunctionParameterValues();
				  my $operation = $attribute->getAssignmentOutputFunctionName(); 

				  if ($operation eq "getIBMVoiceGatewaySessionId") { 					  
			%> 
				  // Send the current vgwSessionId.
				  oTuple.set_<%=$name%>( 
						<%=$operation%>(con_metadata.vgwSessionId));
				  <%} elsif ($operation eq "isCustomerSpeechData") { 
			%> 
				  oTuple.set_<%=$name%>( 
						<%=$operation%>(con_metadata.vgwIsCaller));
				  <%} elsif ($operation eq "getTupleCnt") { 
			%> 
				  oTuple.set_<%=$name%>( 
						<%=$operation%>(con_metadata.speechPacketsReceivedCnt));
				  <%} elsif ($operation eq "getTotalSpeechDataBytesReceived") { 
			%> 
			  	  oTuple.set_<%=$name%>( 
			  			<%=$operation%>(con_metadata.speechDataBytesReceived));
			  	  <%} elsif ($operation eq "getVoiceChannelNumber") { 
			%> 
				   oTuple.set_<%=$name%>( 
						<%=$operation%>(con_metadata.vgwVoiceChannelNumber));
		  	  	  <%} elsif ($operation eq "getAgentPhoneNumber") { 
		    %> 
			   	   oTuple.set_<%=$name%>( 
			   			getAgentOrCallerPhoneNumber(con_metadata.vgwSessionId, false));
	  	  	  	  <%} elsif ($operation eq "getCallerPhoneNumber") { 
	  	  	%> 
		   	   	   oTuple.set_<%=$name%>( 
		   	   			getAgentOrCallerPhoneNumber(con_metadata.vgwSessionId, true));
		  	  	  <%} elsif ($operation eq "getCallStartDateTime") { 
		  	%> 
		  		   oTuple.set_<%=$name%>( 
		  		   	    <%=$operation%>(con_metadata.callStartDateTime));
		  		  <%}
			}%>
						
			submit(oTuple, 0);

			if (vgwSessionLoggingNeeded == true) {
				SPLAPPTRC(L_INFO, "Operator " << operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) <<
					"-->X2 Received speech data from the vgwSessionId " << 
					con_metadata.vgwSessionId << 
					" and sent it via an output tuple. " <<
					"vgwIsCaller=" << con_metadata.vgwIsCaller <<
					", vgwVoiceChannelNumber=" << con_metadata.vgwVoiceChannelNumber <<
					", speechPacketsReceivedCnt=" <<
					con_metadata.speechPacketsReceivedCnt <<
					", currentSpeechPacketSize=" << payloadSize <<
					", totalSpeechDataBytesReceived=" <<
					con_metadata.speechDataBytesReceived, "on_message");
			}
			
			return;
		} else {
			if (vgwSessionLoggingNeeded == true) {
				SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) <<
					"-->X2 Received binary content via connection handle " <<
					hdl.lock().get() << 
					" when it is not expected: " <<
					msg->get_payload() << 
					". So, this message from the IBM Voice Gateway is ignored when " <<
					"the current session status is not VGW_STARTED_AN_STT_SESSION.", "on_message");
			}		
			
			return;
		} // End of if (con_metadata.vgwSessionStatus == VGW_STARTED_AN_STT_SESSION)
	} // End of if (msg->get_opcode() == websocketpp::frame::opcode::binary)
}

// When a client's established connection closes, this callback method is run.
void MY_OPERATOR::on_close(websocketpp::connection_hdl hdl) {
	connection_metadata con_metadata;
	
	try {
		// Get the metadata details for this connection handle from our client connections map.
		con_metadata = get_con_metadata_from_hdl(hdl);
	} catch (const std::invalid_argument & e) {
		SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) << 
			"-->hdl=" << hdl.lock().get() <<
			".-->X3 Unable to get con_metadata-->" << e.what(), "on_close");
		return;
	} catch (...) {
		SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) << 
			"-->hdl=" << hdl.lock().get() <<
			".-->X3 Unable to get con_metadata-->Other exception occurred.", "on_close");
		return;
	}
		
	int64_t currentTimeInSeconds = 
		SPL::Functions::Time::getSeconds(SPL::Functions::Time::getTimestamp());
	int64_t sessionDuration = currentTimeInSeconds - con_metadata.vgwSessionStartTime;
	
	bool vgwSessionLoggingDone = false;
	
	if (vgwSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, "on_close called for hdl: " << 
			hdl.lock().get() << 
			", vgwSessionId: " << con_metadata.vgwSessionId <<
			", vgwIsCaller: " << con_metadata.vgwIsCaller <<
			", sessionDuration: " << sessionDuration << " seconds.", "on_close");
		vgwSessionLoggingDone = true;
	}
	
	if (vgwSessionLoggingDone == false) {
		SPLAPPTRC(L_INFO, "on_close called for hdl: " << 
			hdl.lock().get() << 
			", vgwSessionId: " << con_metadata.vgwSessionId <<
			", vgwIsCaller: " << con_metadata.vgwIsCaller <<
			", sessionDuration: " << sessionDuration << " seconds.", "on_close");
	}

	// We have a map where the agent and caller phone numbers of a given
	// call session id are stored. Since this leg of that call is ending,
	// let us remove the corespoding entry from that map.
	//
	// Key: vgeSessionId_vgwIsCaller
	// Value: Phone Number
	std::string key = con_metadata.vgwSessionId + std::string("_") + 
		boost::to_string(con_metadata.vgwIsCaller);
	auto it = vgwSessionPhoneNumbersMap.find(key);

	if (it != vgwSessionPhoneNumbersMap.end()) {
		// it->first has the key of the map and it->second has the value.
		vgwSessionPhoneNumbersMap.erase(it->first);
	}	

	// **** IMPORTANT CHANGE ****
	// Jan/15/2021. Senthil deactivated the {action == "stop"} logic in the on_message method above and
	// moved that entire logic here. The reason for that is "stop" message coming from VGW is
	// not always guaranteed or in other words not fully consistent. If there is a network overload or 
	// VGW media relay issues in the middle of a call, VGW will not be able to send the "stop" message.
	// If we don't receive the "stop" message for a voice channel in an ongoing call, then this operator
	// will not send the "EOCS" signal to the underlying SPL application for it to do the necessary
	// post-call clean-up and release of the allocated STT engines. If this happens for a prolonged
	// period for many calls, then that may result in all the STT engines to be in unreleased state which 
	// in turn will not transcribe any future calls citing that "No available STT engines".
	// So, we will not depend on the "stop" message anymore. I made the "stop" logic in the on_message 
	// method to be inactive. Whenever a voice channel's WebSocket client connection gets closed, we will
	// perform the exact logic that was earlier done in the on_message method. Unlike the "stop" message,
	// a WebSocket client connection closure will always happen. So, logic below to send the EOCS signal 
	// should be a lot more robust and reliable.
	//
	// Update this metric.
	nSpeechDataBytesReceived += (uint64_t)con_metadata.speechDataBytesReceived;
	nOutputTuplesSent += (uint64_t)con_metadata.speechPacketsReceivedCnt;

	// It is a stop session message sent by the IBM Voice Gateway.
	// We can delete this connection's meta data cached in our
	// client connection map.
	if (vgwSessionLoggingNeeded == true) {
		SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) <<
			"-->X3 Preparing to send End Of Call Signal (EOCS) for the vgwSessionId " << 
			con_metadata.vgwSessionId << 
			", vgwIsCaller=" << con_metadata.vgwIsCaller << 
			", vgwVoiceChannelNumber=" << con_metadata.vgwVoiceChannelNumber <<
			".", "on_close");
	}					

	// There may be more than one channel in the voice call for this
	// vgwSessionId. All we know is that this particular channel (i.e. connection)
	// that we have here is ending its STT session. We will go ahead and send an
	// "End of Voice Call" signal to the downstream operator in order for it to 
	// free up the necessary things handling this speaker of a given 
	// voice call i.e. vgwSessionId_vgwVoiceChannelNumber combo. 
	// If this happens to be the very last channel doing the "End session" in a 
	// multi-channel voice call, we will also do the following cleanup.
	// [Most of the voice calls will have two different channels: 
	//  one for the customer speech and the other for the agent speech.]
	bool vgwSessionIdFoundInMap = 
		vgw_session_id_map.find(con_metadata.vgwSessionId) != vgw_session_id_map.end();
	
	// For the correct call clean-up operation, this operator must have received
	// call start session messages for both the voice channels in a call and it 
	// must have also received speech data bytes from both the voice channels 
	// (either silence fillers or real speech data). In that case,
	// vgwVoiceChannelNumber must correctly be set to either 1 or 2.
	// If not, that is going to cause trouble for the downstream operator logic 
	// in properly releasing the speech engines assigned for a given call. 
	// Please see the log message that will get written in the else block below.
	if (vgwSessionIdFoundInMap == true && con_metadata.vgwVoiceChannelNumber > 0) {
		// Send the "End of Voice Call" signal now for this
		// vgwSessionId_vgwVoiceChannelNumber combo.
		OPort0Type oTuple;
		oTuple.set_vgwSessionId(con_metadata.vgwSessionId);
		oTuple.set_isCustomerSpeechData(con_metadata.vgwIsCaller);
		oTuple.set_vgwVoiceChannelNumber(con_metadata.vgwVoiceChannelNumber);
		oTuple.set_endOfCallSignal(true);
		submit(oTuple, 0);
		
		if (vgwSessionLoggingNeeded == true) {
			SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
				"-->Channel " << boost::to_string(udpChannelNumber) <<
				"-->X3 Sent an 'End of Voice Call' signal for vgwSessionId=" << 
				con_metadata.vgwSessionId << 
				", vgwVoiceChannelNumber=" <<
				con_metadata.vgwVoiceChannelNumber << ".", "on_close");
		}					

		// Make the adjustment by removing the 
		// last entry in the list being held inside this map. 
		vgw_session_id_map[con_metadata.vgwSessionId].pop_back();
		
		if (vgw_session_id_map[con_metadata.vgwSessionId].size() <= 0) {
			// There are no more active channels for this vgwSessionId.
			// This channel is the very last one in this voice call to end the session.
			// So, let us remove it from the map.
			vgw_session_id_map.erase(con_metadata.vgwSessionId);

			// A voice call is fully completed now. Update this metric.
			nVoiceCallsProcessed++;
			// Update the operator metric only if the user asked for a live update.
			if (vgwLiveMetricsUpdateNeeded == true) {
				nVoiceCallsProcessedMetric->setValueNoLock(nVoiceCallsProcessed);
				nSpeechDataBytesReceivedMetric->setValueNoLock(nSpeechDataBytesReceived);
				nOutputTuplesSentMetric->setValueNoLock(nOutputTuplesSent);
			}						
		} // End of if (vgw_session_id_map[con_metadata.vgwSessionId] <= 0)
	} else {
		SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
			"-->Channel " << boost::to_string(udpChannelNumber) <<
			"-->Possible critical error: Received on_close for connection handle " <<
			hdl.lock().get() << 
			" with its VGW session id not found in the vgw_session_id_map. " <<
			"Reason for this could be either the VGW never sent a start session "  <<
			"message for one of the voice channels or it sent a start session message "
			"followed by no binary speech data for that voice channel. This will " <<
			"cause less than the required number of EOCS tuples to be sent to the " <<
			"downstream operator. Unless the downstream operator is configured to " <<
			"handle the reduced number of EOCS tuples for a given VGW session id, " <<
			"it may eventually end up with all the speech processors and the " << 
			"speech engines to be in unreleased i.e. unavailable state for handling " <<
			"any new voice calls. vgwVoiceChannelNumber must be either 1 or 2. " <<
			"If it is not, then it indicates the situation described above. " <<
			"vgwSessionId=" << con_metadata.vgwSessionId << 
			", vgwVoiceChannelNumber=" <<
			con_metadata.vgwVoiceChannelNumber << ".", "on_close");
	} // End of if (vgwSessionIdFoundInMap == true)

	// This entire if block is a carry-over from the "stop" message processing section in the
	// on_message method. I'm simply retaining that code block here. With the EOCS signal being
	// now sent in this on_close method, we should not experience any stale sessions.
	// Hence, this stale session purging logic will hardly ever get executed.
	if (vgwStaleSessionPurgeInterval > 0) {
		// PERIODIC STALE SESSION AND STALE CONNECTION REMOVAL.
		// Do this only if the user provided a non-zero purge interval.
		// We should be prepared for a condition where the
		// "Stop STT session" message never arrives for some reason.
		// One reason this can happen is due to an abnormal crash or
		// an abnormal exit/closure on the VGW side of things.
		// In that case, it will leave us with left over map entries.
		// So, we will have to purge those left over map entries.
		// Similarly, any unclosed client connection (which is 
		// extremely rare) will also leave stale entries in the map.
		// We will remove all such things here periodically.
		int64_t currentTimeInSeconds = 
			SPL::Functions::Time::getSeconds(SPL::Functions::Time::getTimestamp());
		
		if (currentTimeInSeconds - timeOfPreviousStaleSessionRemoval >=
			vgwStaleSessionPurgeInterval) {
			// Time elapsed. Time to check for stale entries.
			std::list<std::string> staleList;
			staleList.clear();
					
			// Let us first check inside the VGW session id map.
			for(std::map<std::string, SPL::list<int64_t>>::iterator it = vgw_session_id_map.begin();
				it != vgw_session_id_map.end(); it++) {
				// SPL::list is nothing but an std::vector behind the scenes.
				SPL::list<int64_t> myList = it->second;
				
				// Loop through this list and check every voice channel's start time.
				for(SPL::list<int64_t>::iterator it2 = myList.begin();
					it2 != myList.end(); it2++) {
					if (currentTimeInSeconds - *it2 >=
						vgwStaleSessionPurgeInterval) {
						// This is a stale entry. Store the VGW session id.
						staleList.push_back(it->first);
						break;
					}
				}
			}
			
			// Now, we can remove the stale entries if any.
			for(std::list<std::string>::iterator it = staleList.begin();
				it != staleList.end(); it++) {
				vgw_session_id_map.erase(*it);
				
				if (vgwSessionLoggingNeeded == true) {
					SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
						"-->Channel " << boost::to_string(udpChannelNumber) <<
						"-->X4 Removed a stale VGW session id. " <<
						*it, "on_close");
				}
				
				// Added this logic on Sep/04/2020.
				// Since we know the VGW session id that has gone stale,
				// we can attempt to clean up a few more things on a 
				// best effort basis as shown below.
				//
				// Since this connection has gone stale, we can send an 
				// abnormal, delayed EndOfCall Signal via the output port.
				// That can help the underlying application logic to
				// do its own clean-up and release of the STT engines.
				// Send the "End of Voice Call" signal now for this
				// vgwSessionId_vgwVoiceChannelNumber combo.
				// Send it for voice channel 1 which is an 
				// agent channel most of the time.
				OPort0Type oTuple;
				oTuple.set_vgwSessionId(*it);
				oTuple.set_isCustomerSpeechData(false);
				oTuple.set_vgwVoiceChannelNumber(1);
				oTuple.set_endOfCallSignal(true);
				submit(oTuple, 0);
				// Do the same for voice channel 2 which is a
				// customer channel most of the time.
				oTuple.set_vgwSessionId(*it);
				oTuple.set_isCustomerSpeechData(true);
				oTuple.set_vgwVoiceChannelNumber(2);
				oTuple.set_endOfCallSignal(true);
				submit(oTuple, 0);
				
				// We have a map where the agent and caller phone numbers of a given
				// call session id are stored. Since this call has gone stale,
				// let us remove the corespoding entry from that map.
				//
				// Key: vgeSessionId_vgwIsCaller
				// Value: Phone Number
				// Let us remove the agent's phome first.
				bool vgwIsCaller = false;
				std::string key = *it + std::string("_") + 
					boost::to_string(vgwIsCaller);
				auto it2 = vgwSessionPhoneNumbersMap.find(key);

				if (it2 != vgwSessionPhoneNumbersMap.end()) {
					// it2->first has the key of the map and it->second has the value.
					vgwSessionPhoneNumbersMap.erase(it2->first);
				}	

				// Let us also try to remove the caller's phone.
				vgwIsCaller = true;
				key = *it + std::string("_") + boost::to_string(vgwIsCaller);
				auto it3 = vgwSessionPhoneNumbersMap.find(key);

				if (it3 != vgwSessionPhoneNumbersMap.end()) {
					// it3->first has the key of the map and it->second has the value.
					vgwSessionPhoneNumbersMap.erase(it3->first);
				}	
			} // End of for loop.
			
			std::list<websocketpp::connection_hdl> staleList2;
			staleList2.clear();
			
			// Let us now check the client connections map.
			// Stale entries happening in this map is a rarity just because
			// on_close handler almost always gets invoked during the
			// normal as well as abnormal client connection closures.
			for(con_map::iterator it = client_connections_map.begin();
				it != client_connections_map.end(); it++) {
				connection_metadata cmd = it->second;
				
				if(currentTimeInSeconds - cmd.vgwSessionStartTime > 
					vgwStaleSessionPurgeInterval) {
					// This is a stale entry. Store the connection handle.
					staleList2.push_back(it->first);
					
					// Added this logic on Sep/04/2020.
					// NOTE: We already made an attempt to do this same logic
					// inside the previous for loop. We are doing the same 
					// here again using the connection data. This should not 
					// cause any harm. If a duplicate EOCS is sent from here,
					// the underlying app;ication logic should do the right
					// thing to ignore if that EOCS is redundant.
					//
					// Since this connection has gone stale, we can send an 
					// abnormal, delayed EndOfCall Signal via the output port.
					// That can help the underlying application logic to
					// do its own clean-up and release of the STT engines.
					// Send the "End of Voice Call" signal now for this
					// vgwSessionId_vgwVoiceChannelNumber combo.
					OPort0Type oTuple;
					oTuple.set_vgwSessionId(cmd.vgwSessionId);
					oTuple.set_isCustomerSpeechData(cmd.vgwIsCaller);
					oTuple.set_vgwVoiceChannelNumber(cmd.vgwVoiceChannelNumber);
					oTuple.set_endOfCallSignal(true);
					submit(oTuple, 0);
					
					// Added this logic on Sep/04/2020.
					// We have a map where the agent and caller phone numbers of a given
					// call session id are stored. Since this leg of that call has gone stale,
					// let us remove the corespoding entry from that map.
					//
					// Key: vgeSessionId_vgwIsCaller
					// Value: Phone Number
					std::string key = cmd.vgwSessionId + std::string("_") + 
						boost::to_string(cmd.vgwIsCaller);
					auto it = vgwSessionPhoneNumbersMap.find(key);

					if (it != vgwSessionPhoneNumbersMap.end()) {
						// it->first has the key of the map and it->second has the value.
						vgwSessionPhoneNumbersMap.erase(it->first);
					}	
				} // End of if(currentTimeInSeconds - cmd.vgwSessionStartTime > 
			} // End of  for loop.

			int32_t stale2RemovedCnt = 0;
			// Now, we can remove the stale entries if any.
			for(std::list<websocketpp::connection_hdl>::iterator it = staleList2.begin();
				it != staleList2.end(); it++) {
				client_connections_map.erase(*it);
				stale2RemovedCnt++;
			}

			if (vgwSessionLoggingNeeded == true && stale2RemovedCnt > 0) {
				SPLAPPTRC(L_ERROR, "Operator " << operatorPhysicalName <<
					"-->Channel " << boost::to_string(udpChannelNumber) <<
					"-->X4 Removed a few stale client connection handles. Removed count=" <<
					stale2RemovedCnt, "on_close");
			}
			
			// Set it to the current time so that we can do our next 
			// stale sesion data removal at the required time interval.
			timeOfPreviousStaleSessionRemoval = currentTimeInSeconds;
		}
	} // End of if (vgwStaleSessionPurgeInterval > 0)

	// Delete this handle from our associative container.        
	client_connections_map.erase(hdl);
} // End of on_close method.

// This is a callback that can return a password if the 
// server-side key file is configured with a key password to be
// provided at the time of loading it in the on_tls_init method.
std::string MY_OPERATOR::get_private_key_password() {
	return (certificatePassword);
}

// This is an utility method to get the client connection meta data for a given connection handle.
MY_OPERATOR::connection_metadata& MY_OPERATOR::get_con_metadata_from_hdl(websocketpp::connection_hdl hdl) {
	auto it = client_connections_map.find(hdl);
        
	if (it == client_connections_map.end()) {
		std::ostringstream errorStringStream;
		errorStringStream << 
			"No connection metadata avaliable for a given connection handle: " << hdl.lock().get();
		std::string error_string = errorStringStream.str();
		// This connection is not in the list. This really shouldn't happen
		// and probably means something else is wrong.
		throw std::invalid_argument(error_string.c_str());
	}
    
	// it->first has the key of the map and it->second has the value.
	return it->second;
}

// Tuple processing for mutating ports 
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
    // Sample submit code
    /* 
      submit(otuple, 0); // submit to output port 0
    */
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
    // Sample submit code
    /* 
      OPort0Type otuple;
      submit(otuple, 0); // submit to output port 0
    */
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
    /*
      if(punct==Punctuation::WindowMarker) {
        // ...;
      } else if(punct==Punctuation::FinalMarker) {
        // ...;
      }
    */
}

// IBMVoiceGatewaySource Output Functions that are needed to set the output tuple attributes with their values.
std::string MY_OPERATOR::getIBMVoiceGatewaySessionId(std::string const & vgwSessionId) {
	return(vgwSessionId); 
}

bool MY_OPERATOR::isCustomerSpeechData(bool const & isThisSpeechDataFromCustomer) {
	return(isThisSpeechDataFromCustomer);
}

int32_t MY_OPERATOR::getTupleCnt(int32_t const & emittedTupleCnt) {
	return(emittedTupleCnt);
}

int32_t MY_OPERATOR::getTotalSpeechDataBytesReceived(int32_t const & totalSpeechDataBytesReceived) {
	return(totalSpeechDataBytesReceived);
}

int32_t MY_OPERATOR::getVoiceChannelNumber(int32_t const & voiceChannelNumber) {
	return(voiceChannelNumber);
}

std::string MY_OPERATOR::getAgentOrCallerPhoneNumber(std::string const & vgwSessionId, 
	bool const & vgwIsCaller) {
	// We will use the isCaller argument to determine whether it is an 
	// agent number or a caller number.
	// Read the commentary in the .h file for the connection_metadata structure to
	// gain more background about what is going on with the vgwIsCaller and the
	// vgwVoiceChannelNumber.
	//
	// We have a map that holds the agent and caller phone numbers for a given voice call session.
	// Key: vgeSessionId_vgwIsCaller
	// Value: Phone Number
	std::string key = vgwSessionId + std::string("_") + boost::to_string(vgwIsCaller);
	auto it = vgwSessionPhoneNumbersMap.find(key);

	if (it == vgwSessionPhoneNumbersMap.end()) {
		// We couldn't find it in the map.
		return(std::string(""));
	} else {
		// it->first has the key of the map and it->second has the value.
		return it->second;
	}
}

SPL::rstring MY_OPERATOR::getCallStartDateTime(SPL::rstring const & callStartDateTime) {
	return(callStartDateTime);
}

<%SPL::CodeGen::implementationEpilogue($model);%>
